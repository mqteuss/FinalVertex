<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, shrink-to-fit=no, viewport-fit=cover">
    <title>Final Vertex</title>

    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#8a8aff">
    <link rel="apple-touch-icon" href="icon-192x192.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<style>
        :root {
            --primary-bg: #1a1a2a;
            --secondary-bg: #2a2a3e;
            --accent-bg: #4a4a6e;
            --light-text: #f0f0f0;
            --dark-border: #11111f;
            --health-color: #ff4d4d;
            --xp-color: #4dff9e;
            --player-color: #8a8aff;
            --gem-color: #ffff4d;
        }
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body {
            font-family: 'Press Start 2P', cursive;
            touch-action: none;
            background-color: var(--primary-bg);
            color: var(--light-text);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        canvas {
            background-color: var(--secondary-bg);
            display: block;
            image-rendering: pixelated;
            width: 100%; 
            height: 100%;
        }
        .hud-bar {
            position: relative;
            height: 1rem;
            background-color: var(--primary-bg);
            border-radius: 4px;
            overflow: hidden;
            border: 2px solid var(--dark-border);
        }
        .hud-bar::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: repeating-linear-gradient(
                90deg,
                transparent,
                transparent 8px,
                rgba(0,0,0,0.4) 8px,
                rgba(0,0,0,0.4) 10px
            );
            pointer-events: none;
        }
        .hud-bar-fill {
            height: 100%;
            transition: width 0.3s ease-in-out;
        }
        #health-bar-fill { background-color: var(--health-color); }
        #xp-bar-fill { background-color: var(--xp-color); }
        .modal {
            position: fixed;
            inset: 0;
            background-color: rgba(0,0,0,0.7);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            animation: fadeIn 0.3s ease;
        }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .modal-content {
            background-color: var(--secondary-bg);
            border: 4px solid var(--light-text);
            padding: 1.5rem;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            animation: scaleUp 0.3s ease;
        }
        @keyframes scaleUp { from { transform: scale(0.9); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        #hud {
            top: calc(2.5rem + env(safe-area-inset-top)); 
        }
        .btn {
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            transition: all 0.1s ease-out;
            border: 2px solid var(--light-text);
            border-radius: 6px;
            background-color: var(--accent-bg);
            color: var(--light-text);
            text-transform: uppercase;
            cursor: pointer;
            box-shadow: 0 4px 0 var(--dark-border), 0 5px 5px rgba(0,0,0,0.4);
        }
        .btn:hover { background-color: #6a6a8e; }
        .btn:active {
            transform: translateY(2px) scale(0.98);
            box-shadow: 0 2px 0 var(--dark-border);
        }
        .btn:disabled {
            background-color: #3a3a5e;
            cursor: not-allowed;
            opacity: 0.7;
            box-shadow: 0 2px 0 var(--dark-border);
            transform: translateY(2px);
        }
        .quality-btn.active, .controls-btn.active, .toggle-btn.active {
            background-color: var(--player-color);
            box-shadow: 0 2px 0 var(--dark-border), inset 0 0 10px rgba(0,0,0,0.3);
            transform: translateY(2px);
        }
        #start-modal h1 {
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.4), 0 0 15px rgba(138, 138, 255, 0.3);
        }
        .card {
            background-color: #3a3a5e;
            border: 3px solid var(--light-text);
            transition: all 0.2s ease;
            cursor: pointer;
                        overflow: hidden;
            position: relative; /* ADICIONADO */
        }
        .card:hover:not(.locked) {
            transform: translateY(-5px) scale(1.02);
            background-color: var(--accent-bg);
        }
        .card.locked {
            background-color: var(--secondary-bg);
            cursor: not-allowed;
            opacity: 0.6;
        }
        /* AJUSTE VISUAL: O card de evolu√ß√£o agora foca no brilho, combinando com o novo estilo das raridades */
        .card.evolution-card {
            box-shadow: 0 0 15px #ffd700, inset 0 0 20px #ffd70022;
        }
        #joystick-container {
            position: absolute;
            display: none;
            width: 120px;
            height: 120px;
            z-index: 5;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: opacity 0.1s ease-in-out;
            pointer-events: none;
        }
        #joystick-base {
            width: 100%; height: 100%;
            background-color: rgba(240, 240, 255, 0.4);
            border-radius: 50%;
        }
        #joystick-thumb {
            position: absolute; width: 60px; height: 60px;
            background-color: var(--player-color); border-radius: 50%;
            top: 30px; left: 30px;
            pointer-events: none;
        }
/* --- ESTILOS PARA BOT√ïES DE HABILIDADE (MOBILE) --- */
        .ability-btn {
            display: none; /* Escondido por padr√£o, aparece em @media (pointer: coarse) */
            position: absolute;
            background-color: var(--player-color);
            border-radius: 50%;
            align-items: center;
            justify-content: center;
            color: var(--primary-bg);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            overflow: hidden;
            z-index: 5;
        }
        .ability-cooldown-overlay {
            position: absolute;
            bottom: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            transition: height 0.1s linear;
            pointer-events: none;
        }
        #dash-button {
            width: 80px; height: 80px;
            bottom: 4rem;
            right: 2rem;
            right: calc(2rem + env(safe-area-inset-right));
            left: auto;
        }
        #parry-button, #push-button {
            width: 60px; height: 60px;
            right: 1.5rem;
            right: calc(1.5rem + env(safe-area-inset-right));
            left: auto;
        }
        #parry-button { bottom: calc(4rem + 80px + 1rem); }
        #push-button { bottom: calc(4rem + 80px + 1rem + 65px + 1rem); }

        .controls-inverted .ability-btn {
            right: auto;
            left: 2rem;
            left: calc(2rem + env(safe-area-inset-left));
        }
        .controls-inverted #parry-button, .controls-inverted #push-button {
            right: auto;
            left: 2.5rem;
            left: calc(2.5rem + env(safe-area-inset-left));
        }

        /* --- ESTILOS PARA SLOTS DE HABILIDADE (PC) --- */
        #ability-slots-pc {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 6;
            display: none; /* Escondido por padr√£o, gerenciado por media query */
            gap: 1rem;
            background-color: rgba(0,0,0,0.3);
            padding: 0.5rem;
            border-radius: 8px;
            border: 2px solid var(--accent-bg);
        }
        .ability-slot {
            width: 60px;
            height: 60px;
            background-color: var(--secondary-bg);
            border: 2px solid var(--light-text);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        .ability-slot .key-hint {
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 0.7rem;
            opacity: 0.8;
        }
        #ability-slots-pc svg {
            width: 35px;
            height: 35px;
            stroke: var(--light-text);
        }
        .volume-slider {
            -webkit-appearance: none; appearance: none;
            height: 8px; background: var(--primary-bg);
            border: 2px solid var(--light-text); border-radius: 4px;
            outline: none; cursor: pointer;
            transition: box-shadow 0.2s ease;
        }
        .volume-slider:hover { box-shadow: 0 0 8px var(--player-color); }
        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 20px; height: 20px;
            background: var(--player-color);
            border: 2px solid var(--light-text);
            border-radius: 50%;
        }
        .volume-slider::-moz-range-thumb {
            width: 20px; height: 20px;
            background: var(--player-color);
            border: 2px solid var(--light-text);
            border-radius: 50%;
        }
        .tab-btn {
            background-color: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            padding-bottom: 0.5rem;
            margin-bottom: -2px;
            border-radius: 0;
            box-shadow: none;
        }
        .tab-btn:active {
            transform: none;
            box-shadow: none;
        }
        .tab-btn.active-tab {
            border-bottom-color: var(--player-color);
            color: var(--light-text);
        }
        #pause-summary h3, #changelog-content h3 {
            border-bottom: 2px solid var(--accent-bg);
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }
        #pause-summary ul, #changelog-content ul { 
            list-style: none; 
            padding: 0; 
            padding-left: 0.5rem;
        }
        #pause-summary li, #changelog-content li {
            background-color: var(--primary-bg);
            padding: 0.5rem 0.75rem;
            border-radius: 4px;
            margin-bottom: 0.5rem;
            font-size: 0.8rem;
        }
         #changelog-content li {
            background-color: transparent;
            padding-left: 0;
            position: relative;
            padding-left: 1.5rem; /* Space for the icon */
        }
        #changelog-content li::before {
            content: '‚ô¶';
            color: var(--gem-color);
            position: absolute;
            left: 0;
            top: 0.5rem;
        }
 @media (pointer: coarse) {
            .ability-btn { display: flex; }
            #joystick-container { display: block; }
            #ability-slots-pc { display: none; }
        }
                @media (pointer: fine) {
            .ability-btn { display: none; }
            #ability-slots-pc { display: flex; }
        }
@media (max-width: 640px) {
            .modal-content { padding: 1.5rem 1rem; }
            .btn { padding: 0.75rem 1rem; font-size: 0.9rem; }
            #joystick-container { width: 100px; height: 100px; }
            #joystick-thumb { width: 50px; height: 50px; top: 25px; left: 25px; }
            .modal-content h1 { font-size: 1.8rem !important; }
            .modal-content h2 { font-size: 1.5rem !important; }
            #dash-button { width: 70px; height: 70px; }
            #parry-button, #push-button { width: 60px; height: 60px; }
            #parry-button { bottom: calc(4rem + 70px + 1rem); }
            #push-button { bottom: calc(4rem + 70px + 1rem + 60px + 1rem); }
        }
 @media (orientation: landscape) and (max-height: 500px) {
            #hud { left: 0.5rem; right: 0.5rem; top: calc(0.5rem + env(safe-area-inset-top)); }
            #level-text, #wave-timer { font-size: 0.75rem; }
            .hud-bar { height: 0.75rem; }
            .modal-content { padding: 1rem; max-height: 95vh; }
            .modal-content h1, .modal-content h2 { font-size: 1.25rem !important; margin-bottom: 0.75rem !important; }
            .modal-content p { font-size: 0.8rem; margin-bottom: 1rem !important; }
            #ability-modal h2 { font-size: 1.25rem !important; margin-bottom: 1rem !important; }
            #ability-options { grid-template-columns: repeat(3, 1fr); gap: 0.75rem; }
            #ability-options .card { padding: 0.75rem; }
            #ability-options .card h3 { font-size: 0.8rem; margin-bottom: 0.25rem; }
            #ability-options .card p { font-size: 0.65rem; }
            #dash-button { width: 65px; height: 65px; bottom: 1rem; right: 1rem; }
            #parry-button, #push-button { width: 55px; height: 55px; right: 1.25rem; }
            #parry-button { bottom: calc(1rem + 65px + 0.5rem); }
            #push-button { bottom: calc(1rem + 65px + 0.5rem + 55px + 0.5rem); }
            .controls-inverted .ability-btn { left: 1rem; }
            .controls-inverted #parry-button, .controls-inverted #push-button { left: 1.25rem; }
        }
</style>
<body class="text-white">
    <div id="game-container" class="relative w-screen h-screen">
        <canvas id="game-canvas"></canvas>
        <div id="hud" class="absolute left-4 right-4" style="display: none;">
            <div id="boss-hud" class="w-full px-4 mb-4" style="display: none;">
                <p id="boss-name" class="text-center text-xl mb-2 text-purple-300"></p>
                <div class="hud-bar w-full h-6 border-4 border-purple-400 bg-purple-900/50">
                    <div id="boss-health-bar-fill" class="hud-bar-fill" style="background-color: #be4dff;"></div>
                </div>
            </div>
            <div class="flex justify-between items-center mb-2">
                <div id="level-text" class="text-base sm:text-lg">N√≠vel 1</div>
                <div id="gems-container" class="flex items-center gap-2">
                    <span id="gem-icon" class="text-yellow-400">‚ô¶</span>
                    <span id="run-gems-count">0</span>
                </div>
                <div id="wave-timer" class="text-base sm:text-lg"></div>
            </div>
            <div class="flex w-full gap-2 mt-2">
                <div class="hud-bar w-full">
                    <div id="health-bar-fill" class="hud-bar-fill"></div>
                </div>
                <div class="hud-bar w-full">
                    <div id="xp-bar-fill" class="hud-bar-fill"></div>
                </div>
            </div>
        </div>
        <div id="start-modal" class="modal">
            <div class="modal-content text-center">
                <h1 class="text-3xl sm:text-4xl mb-4">Final Vertex</h1>
                <p class="mb-8">Derrote hordas de inimigos e fique mais forte.</p>
                <div class="flex flex-col gap-4">
                    <button id="start-button" class="btn">Iniciar Jogo</button>
                    <button id="upgrades-button" class="btn">Arsenal</button>
                    <button id="quests-button" class="btn">Miss√µes</button>
                    <button id="options-button" class="btn">Ajustes</button>
                </div>
                 <div class="absolute top-4 right-4 flex items-center gap-2 text-lg">
                    <span class="text-yellow-400">‚ô¶</span>
                    <span id="total-gems-count">0</span>
                </div>
            </div>
        </div>
        <div id="changelog-modal" class="modal" style="display: none;">
            <div class="modal-content">
                <h2 class="text-2xl sm:text-3xl mb-6 text-center">Novidades da Vers√£o</h2>
                <div id="changelog-content" class="mb-8 text-left max-h-72 overflow-y-auto pr-2">
                    <h3 class="text-xl">üêæ Apresentando os Companheiros! üêæ</h3>
<ul>
    <li>Voc√™ n√£o est√° mais sozinho! Voc√™ ter√° a chance de invocar 1 de <strong>5 companheiros leais</strong> para te ajudar. Apenas um pode ser escolhido por partida!</li>
    <li><strong>Fogo-F√°tuo:</strong> Um esp√≠rito de fogo que ataca inimigos com proj√©teis teleguiados.</li>
    <li><strong>Golem de Pedra:</strong> Um protetor que periodicamente concede um escudo que bloqueia dano.</li>
    <li><strong>Sprite El√©trico:</strong> Uma centelha de energia que atordoa o inimigo mais pr√≥ximo.</li>
    <li><strong>Brotinho Nutriente:</strong> Uma pequena planta que gera orbes de cura para o jogador.</li>
    <li><strong>C√£o Sombrio:</strong> Um fiel c√£ozinho que aumenta seu raio de coleta de orbes e gemas.</li>
    <li>Ap√≥s escolher um companheiro, <strong>melhorias espec√≠ficas para ele</strong> poder√£o aparecer em suas op√ß√µes de n√≠vel!</li>
</ul>

<h3 class="mt-4 text-xl">üëπ O Desafio Final Chegou! üëπ</h3>
<ul>
    <li>Um novo e poderoso chefe final, o <strong>Colosso de Magma</strong>, espera por voc√™ na Onda 20!</li>
    <li>Prepare-se! <strong>4 novos tipos de inimigos</strong> (Assombra√ß√£o, Golem de Cristal, Verme do Abismo e Sentinela Arcana) aparecer√£o apartir da Onda 10.</li>
    <li>Ven√ßa o Anci√£o Espectral (Chefe da Onda 10) para desbloquear <strong>3 novas armas devastadoras</strong> no Arsenal!</li>
</ul>

<h3 class="mt-4 text-xl">‚ú® Novos Sistemas e Itens ‚ú®</h3>
<ul>
    <li><strong>Sistema de Raridade:</strong> Melhorias agora t√™m cores que indicam sua raridade (<strong style="color: #52d681;">Verde</strong>, <strong style="color: #4f8be6;">Azul</strong>, <strong style="color: #a463e8;">Roxo</strong>, <strong style="color: #e6d84f;">Amarelo</strong>, <strong style="color: #e68a4f;">Laranja</strong>), tornando as escolhas mais estrat√©gicas!</li>
    <li><strong>Miss√µes:</strong> Uma nova aba de Miss√µes foi adicionada ao menu para voc√™ completar desafios e ganhar grandes recompensas em gemas. ‚ô¶Ô∏è</li>
    <li><strong>Santu√°rios M√≠sticos:</strong> Santu√°rios de F√∫ria, Prote√ß√£o e Riqueza agora aparecem com mais frequ√™ncia, concedendo b√¥nus tempor√°rios poderosos.</li>
    <li><strong>Rerrolar Melhorias:</strong> N√£o gostou das op√ß√µes? Agora √© poss√≠vel usar gemas da partida para rerrolar as melhorias oferecidas!</li>
    <li><strong>Novos Drops Raros:</strong> Encontre o <strong>Fragmento de Cura</strong> para recuperar 25% da vida e o <strong>Fragmento de √çm√£</strong> para atrair todos os orbes e gemas instantaneamente!</li>
</ul>

<h3 class="mt-4 text-xl">‚öñÔ∏è Balanceamento e Ajustes ‚öñÔ∏è</h3>
<ul>
    <li>Um <strong>Fragmento de √çm√£</strong> garantido agora surge no centro do mapa a cada 2 ondas completas.</li>
    <li>A melhoria "Vigor" agora concede 17% de vida m√°xima, mas n√£o cura mais o jogador totalmente.</li>
    <li>A melhoria "Regenera√ß√£o" foi retrabalhada com 3 n√≠veis distintos e mais eficazes.</li>
    <li>A arma <strong>Bola de Fogo</strong> agora possui um alcance inicial limitado, exigindo melhorias para se tornar global.</li>
    <li>O chefe <strong>Anci√£o Espectral</strong> est√° mais perigoso: seus proj√©teis duram mais e ele agora invoca Ecos de Magos.</li>
    <li>Auras visuais foram adicionadas ao jogador para indicar b√¥nus de santu√°rios ativos.</li>
</ul>
                </div>
                <div class="text-center">
                    <button id="close-changelog-button" class="btn">Fechar</button>
                </div>
            </div>
        </div>
        <div id="quests-modal" class="modal" style="display: none;">
            <div class="modal-content w-[95%] max-w-4xl h-[95vh] flex flex-col p-4 sm:p-6">
                <div class="flex justify-between items-center mb-6">
                     <h2 class="text-2xl sm:text-3xl">Miss√µes</h2>
                     <div class="flex items-center gap-2 text-lg">
                        <span class="text-yellow-400">‚ô¶</span>
                        <span id="quests-gems-count">0</span>
                    </div>
                </div>
                 <div class="flex border-b-2 border-gray-600 mb-4">
                    <button id="show-easy-quests-tab" class="btn tab-btn active-tab">F√°cil</button>
                    <button id="show-medium-quests-tab" class="btn tab-btn">M√©dia</button>
                    <button id="show-hard-quests-tab" class="btn tab-btn">Dif√≠cil</button>
                </div>
                <div class="flex-grow overflow-y-auto pr-2">
                    <div id="easy-quests-container" class="grid grid-cols-1 md:grid-cols-2 gap-4"></div>
                    <div id="medium-quests-container" class="grid grid-cols-1 md:grid-cols-2 gap-4" style="display: none;"></div>
                    <div id="hard-quests-container" class="grid grid-cols-1 md:grid-cols-2 gap-4" style="display: none;"></div>
                </div>
                <div class="mt-6 text-center">
                    <button id="quests-back-button" class="btn">Voltar</button>
                </div>
            </div>
        </div>
        <div id="upgrades-modal" class="modal" style="display: none;">
            <div class="modal-content w-[95%] max-w-4xl h-[95vh] flex flex-col p-4 sm:p-6">
                <div class="flex justify-between items-center mb-6">
                     <h2 class="text-2xl sm:text-3xl">Arsenal</h2>
                     <div class="flex items-center gap-2 text-lg">
                        <span class="text-yellow-400">‚ô¶</span>
                        <span id="upgrades-gems-count">0</span>
                    </div>
                </div>
                 <div class="flex border-b-2 border-gray-600 mb-4">
                    <button id="show-upgrades-tab" class="btn tab-btn active-tab">Melhorias</button>
                    <button id="show-weapons-tab" class="btn tab-btn">Armas</button>
                </div>
                <div class="flex-grow overflow-y-auto pr-2">
                    <div id="upgrades-container" class="grid grid-cols-1 md:grid-cols-2 gap-4"></div>
                    <div id="weapon-shop-container" class="grid grid-cols-1 md:grid-cols-2 gap-4" style="display: none;"></div>
                </div>
                <div class="mt-6 text-center">
                    <button id="upgrades-back-button" class="btn">Voltar</button>
                </div>
            </div>
        </div>
        <div id="options-modal" class="modal" style="display: none;">
            <div class="modal-content w-[95%] max-w-xl h-[95vh] flex flex-col p-4 sm:p-6">
                <h2 class="text-2xl sm:text-3xl mb-6 text-center">Ajustes</h2>
                <div class="flex border-b-2 border-gray-600 mb-6">
                    <button id="show-general-tab" class="btn tab-btn active-tab flex-1">Geral</button>
                    <button id="show-graphics-tab" class="btn tab-btn flex-1">Gr√°ficos</button>
                    <button id="show-audio-tab" class="btn tab-btn flex-1">Som</button>
                </div>
                <div class="flex-grow overflow-y-auto pr-2 text-center">
                    <div id="general-settings-tab">
                        <div class="flex flex-col items-center justify-center gap-6">
                            <div class="w-full">
                                <p class="text-lg mb-2">Layout dos Controles</p>
                                <button id="invert-controls-btn" class="btn controls-btn text-sm p-2 w-40"></button>
                            </div>
                            <div class="w-full">
                                <p class="text-lg mb-2">Indicador de Alvo</p>
                                <button id="target-indicator-btn" class="btn toggle-btn text-sm p-2 w-40"></button>
                            </div>
                        </div>
                    </div>
                    <div id="graphics-settings-tab" style="display: none;">
                        <div class="flex flex-col items-center justify-center gap-6">
                            <div class="w-full">
                                <p class="text-lg mb-2">Qualidade Gr√°fica</p>
                                <div class="flex items-center justify-center gap-4">
                                    <button id="quality-low" class="btn quality-btn text-sm p-2">Baixa</button>
                                    <button id="quality-medium" class="btn quality-btn text-sm p-2">M√©dia</button>
                                    <button id="quality-high" class="btn quality-btn text-sm p-2">Alta</button>
                                </div>
                            </div>
                            <div class="w-full">
                                <p class="text-lg mb-2">Tremor de Tela</p>
                                <button id="screen-shake-btn" class="btn toggle-btn text-sm p-2 w-40"></button>
                            </div>
                            <div class="w-full">
                                <p class="text-lg mb-2">Opacidade dos Efeitos</p>
                                <input type="range" id="effects-opacity-slider" min="0.1" max="1" step="0.05" class="volume-slider w-48">
                            </div>
                        </div>
                    </div>
                    <div id="audio-settings-tab" style="display: none;">
                        <div class="flex flex-col items-center justify-center gap-6">
                             <div class="w-full">
                                 <p class="text-lg mb-2">Volume Geral</p>
                                 <input type="range" id="master-volume-slider" min="0" max="1" step="0.01" class="volume-slider w-48">
                             </div>
                             <div class="w-full">
                                 <p class="text-lg mb-2">Efeitos Sonoros</p>
                                 <input type="range" id="sfx-volume-slider" min="0" max="1" step="0.01" class="volume-slider w-48">
                             </div>
                        </div>
                    </div>
                </div>
                <div class="mt-8 text-center">
                    <button id="options-back-button" class="btn">Voltar</button>
                </div>
            </div>
        </div>
        <div id="ability-modal" class="modal" style="display: none;">
             <div class="modal-content w-full max-w-5xl bg-transparent border-none p-0">
                <h2 class="text-2xl sm:text-3xl mb-8 text-center">Escolha uma Melhoria!</h2>
                <div id="ability-options" class="grid grid-cols-1 md:grid-cols-3 gap-6 px-4"></div>
                <div id="ability-controls" class="mt-8 text-center">
                    <button id="reroll-button" class="btn text-sm p-3"></button>
                </div>
            </div>
        </div>
        <div id="pause-modal" class="modal" style="display: none;">
            <div class="modal-content text-center">
                <h2 class="text-3xl sm:text-4xl mb-6">Pausado</h2>
                <div id="pause-summary" class="mb-8 text-left max-h-60 overflow-y-auto pr-2"></div>
                <div class="flex flex-col gap-4">
                    <button id="resume-button" class="btn">Continuar</button>
                    <button id="quit-button" class="btn">Sair para o Menu</button>
                </div>
            </div>
        </div>
        <div id="game-over-modal" class="modal" style="display: none;">
            <div class="modal-content text-center">
                <h2 id="end-screen-title" class="text-3xl sm:text-4xl mb-2"></h2>
                <p class="text-xl mb-2">Voc√™ sobreviveu por <span id="time-survived"></span>.</p>
                <p id="final-gems-container" class="text-lg mb-4">Gemas Coletadas: <span id="final-gems-count"></span></p>
                <div class="my-6 text-left border-t border-b border-gray-600 py-4 px-2 text-sm sm:text-base">
                    <p class="flex justify-between"><span>Inimigos Derrotados:</span> <span id="enemies-defeated-stat">0</span></p>
                    <p class="flex justify-between mt-2"><span>Dano Total Causado:</span> <span id="damage-dealt-stat">0</span></p>
                    <p class="flex justify-between mt-2"><span>N√≠vel Final:</span> <span id="level-reached-stat">0</span></p>
                </div>
                <button id="restart-button" class="btn mt-6 w-full">Voltar ao Menu</button>
            </div>
        </div>
      <div id="joystick-container">
            <div id="joystick-base"></div>
            <div id="joystick-thumb"></div>
        </div>

        <div id="push-button" class="ability-btn">
             <svg width="35" height="35" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="var(--primary-bg)" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M18 6L6 18M6 6l12 12"></path>
            </svg>
            <div id="push-cooldown-overlay" class="ability-cooldown-overlay"></div>
        </div>

        <div id="parry-button" class="ability-btn">
            <svg width="35" height="35" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="var(--primary-bg)" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
            </svg>
            <div id="parry-cooldown-overlay" class="ability-cooldown-overlay"></div>
        </div>

        <div id="dash-button" class="ability-btn">
             <svg width="40" height="40" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="var(--primary-bg)" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M13 17l5-5-5-5M6 17l5-5-5-5"/>
            </svg>
            <div id="dash-cooldown-overlay" class="ability-cooldown-overlay"></div>
        </div>

        <div id="ability-slots-pc">
            <div id="parry-slot" class="ability-slot">
                <span class="key-hint">Q</span>
                <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
                </svg>
                <div id="parry-slot-cooldown-overlay" class="ability-cooldown-overlay"></div>
            </div>
            <div id="push-slot" class="ability-slot">
                 <span class="key-hint">E</span>
                 <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M18 6L6 18M6 6l12 12"></path>
                </svg>
                <div id="push-slot-cooldown-overlay" class="ability-cooldown-overlay"></div>
            </div>
        </div>
    </div>
    <template id="upgrade-card-template">
        <div class="card p-4 flex flex-col justify-between">
            <div>
                <h4 class="card-title text-xl"></h4>
                <p class="card-description text-sm mt-1 mb-2"></p>
                <p class="card-level-text text-sm">N√≠vel: <span class="card-level"></span></p>
                <p class="card-bonus-text text-sm">B√¥nus: <span class="card-bonus"></span></p>
            </div>
            <div class="mt-4">
                <button class="card-button btn w-full text-sm"></button>
            </div>
        </div>
    </template>
    <template id="quest-card-template">
        <div class="card p-4 flex flex-col justify-between text-left">
            <div>
                <h4 class="quest-title text-base mb-2"></h4>
                <div class="flex justify-between items-center text-sm mb-1">
                    <span class="quest-progress-text"></span>
                    <span class="quest-reward flex items-center gap-1"></span>
                </div>
                <div class="hud-bar h-4">
                    <div class="quest-progress-bar hud-bar-fill" style="background-color: var(--xp-color);"></div>
                </div>
            </div>
            <div class="mt-4">
                <button class="quest-claim-button btn w-full text-sm"></button>
            </div>
        </div>
    </template>
        <script>
// --- Configura√ß√£o Inicial e Elementos do DOM ---
    const GAME_VERSION = "7.21"; // Vers√£o atualizada
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    let screenWidth, screenHeight; 
    const gridCanvas = document.createElement('canvas');
    const gridCtx = gridCanvas.getContext('2d');
    let gridPattern;

    const RARITY_COLORS = {
        1: '#52d681', // Comum (Verde)
        2: '#4f8be6', // Incomum (Azul)
        3: '#a463e8', // Raro (Roxo)
        4: '#e6d84f', // √âpico (Amarelo)
        5: '#e68a4f', // Lend√°rio (Laranja)
    };
    const THREE_LEVEL_RARITY = { 1: 1, 2: 2, 3: 4 };

   const DOM = {
        hud: document.getElementById('hud'),
        healthBar: document.getElementById('health-bar-fill'),
        xpBar: document.getElementById('xp-bar-fill'),
        levelText: document.getElementById('level-text'),
        runGemsCount: document.getElementById('run-gems-count'),
        waveTimerText: document.getElementById('wave-timer'),
        bossHud: document.getElementById('boss-hud'),
        bossName: document.getElementById('boss-name'),
        bossHealthBar: document.getElementById('boss-health-bar-fill'),
        abilityModal: document.getElementById('ability-modal'),
        abilityModalTitle: document.getElementById('ability-modal').querySelector('h2'),
        abilityOptions: document.getElementById('ability-options'),
        rerollButton: document.getElementById('reroll-button'),
        startModal: document.getElementById('start-modal'),
        gameOverModal: document.getElementById('game-over-modal'),
        upgradesModal: document.getElementById('upgrades-modal'),
        startButton: document.getElementById('start-button'),
        upgradesButton: document.getElementById('upgrades-button'),
        upgradesBackButton: document.getElementById('upgrades-back-button'),
        restartButton: document.getElementById('restart-button'),
        timeSurvived: document.getElementById('time-survived'),
        finalGems: document.getElementById('final-gems-count'),
        totalGems: document.getElementById('total-gems-count'),
        upgradesGems: document.getElementById('upgrades-gems-count'),
        upgradesContainer: document.getElementById('upgrades-container'),
        joystickContainer: document.getElementById('joystick-container'),
        joystickThumb: document.getElementById('joystick-thumb'),
        dashButton: document.getElementById('dash-button'),
        dashCooldownOverlay: document.getElementById('dash-cooldown-overlay'),
        parryButton: document.getElementById('parry-button'),
        parryCooldownOverlay: document.getElementById('parry-cooldown-overlay'),
        pushButton: document.getElementById('push-button'),
        pushCooldownOverlay: document.getElementById('push-cooldown-overlay'),
        parrySlotCooldownOverlay: document.getElementById('parry-slot-cooldown-overlay'),
        pushSlotCooldownOverlay: document.getElementById('push-slot-cooldown-overlay'),
        showUpgradesTab: document.getElementById('show-upgrades-tab'),
        showWeaponsTab: document.getElementById('show-weapons-tab'),
        weaponShopContainer: document.getElementById('weapon-shop-container'),
        optionsModal: document.getElementById('options-modal'),
        optionsButton: document.getElementById('options-button'),
        optionsBackButton: document.getElementById('options-back-button'),
        pauseModal: document.getElementById('pause-modal'),
        resumeButton: document.getElementById('resume-button'),
        quitButton: document.getElementById('quit-button'),
        pauseSummary: document.getElementById('pause-summary'),
        enemiesDefeatedStat: document.getElementById('enemies-defeated-stat'),
        damageDealtStat: document.getElementById('damage-dealt-stat'),
        levelReachedStat: document.getElementById('level-reached-stat'),
        showGeneralTab: document.getElementById('show-general-tab'),
        showGraphicsTab: document.getElementById('show-graphics-tab'),
        showAudioTab: document.getElementById('show-audio-tab'),
        generalSettingsTab: document.getElementById('general-settings-tab'),
        graphicsSettingsTab: document.getElementById('graphics-settings-tab'),
        audioSettingsTab: document.getElementById('audio-settings-tab'),
        invertControlsBtn: document.getElementById('invert-controls-btn'),
        qualityLowBtn: document.getElementById('quality-low'),
        qualityMediumBtn: document.getElementById('quality-medium'),
        qualityHighBtn: document.getElementById('quality-high'),
        masterVolumeSlider: document.getElementById('master-volume-slider'),
        sfxVolumeSlider: document.getElementById('sfx-volume-slider'),
        targetIndicatorBtn: document.getElementById('target-indicator-btn'),
        screenShakeBtn: document.getElementById('screen-shake-btn'),
        effectsOpacitySlider: document.getElementById('effects-opacity-slider'),
        changelogModal: document.getElementById('changelog-modal'),
        closeChangelogButton: document.getElementById('close-changelog-button'),
        questsButton: document.getElementById('quests-button'),
        questsModal: document.getElementById('quests-modal'),
        questsBackButton: document.getElementById('quests-back-button'),
        questsGemsCount: document.getElementById('quests-gems-count'),
        showEasyQuestsTab: document.getElementById('show-easy-quests-tab'),
        showMediumQuestsTab: document.getElementById('show-medium-quests-tab'),
        showHardQuestsTab: document.getElementById('show-hard-quests-tab'),
        easyQuestsContainer: document.getElementById('easy-quests-container'),
        mediumQuestsContainer: document.getElementById('medium-quests-container'),
        hardQuestsContainer: document.getElementById('hard-quests-container'),
        endScreenTitle: document.getElementById('end-screen-title'),
        finalGemsContainer: document.getElementById('final-gems-container'),
    };

    // --- Vari√°veis Globais do Jogo ---
    let player, camera, soundManager;
    let enemies = [], expOrbs = [], projectiles = [], enemyProjectiles = [], soulGems = [], particles = [], floatingTexts = [], effects = [], powerups = [], shrines = [];
    let ambientParticles = []; 
    let keys = {}, joystickVector = { x: 0, y: 0 };
    let gameState = 'start';
    let runGems = 0;
    let wave = 1;
    let waveTimer = 30;
    let gameTime = 0;
    let lastTime = 0;
    let animationFrameId;
    let bossWaveActive = false; 
    let currentGraphics; 
    let isMobile = false;
    let runStats = {
        enemiesDefeated: 0,
        damageDealt: 0,
    };
    let playerData = {
        totalSoulGems: 0,
        purchasedUpgrades: {},
        unlockedWeapons: ['fireball'],
        equippedWeapon: 'fireball',
        audio: { masterVolume: 0.5, sfxVolume: 0.8 },
        graphics: { quality: 'medium', screenShake: true, effectsOpacity: 1.0 },
        controls: { inverted: false },
        general: { showTargetIndicator: true },
        persistentStats: {},
        questProgress: {},
        spectralElderDefeated: false,
    };

    // --- Constantes de Configura√ß√£o ---
    const CONFIG = {
        MAP_SIZE: { width: 4000, height: 4000 },
PLAYER: {
            baseMaxHp: 100, baseSpeed: 220, dashSpeed: 1200,
            dashDuration: 0.20, dashCooldown: 1, size: 20,
            basePickupRadius: 120,
            parryDuration: 0.3, parryCooldown: 3,
            parryKnockback: 60, // <-- NOVA PROPRIEDADE PARA FOR√áA DO EMPURR√ÉO
            pushCooldown: 8, pushRadius: 150, pushForce: 400, pushDamage: 5,
        },
        ENEMY: {
            // Inimigos Iniciais (Onda 1-9)
            'slime': { size: 18, color: '#4dff4d', hp: 15, maxHp: 20, speed: 250, damage: 10, xp: 7, stunDuration: 0.5 },
            'bat':   { size: 12, color: '#ff4da6', hp: 20, maxHp: 25, speed: 200, damage: 12, xp: 10, aggroRange: 350, diveSpeed: 1000, diveWindup: 0.3, diveCooldown: 2.5, circlingDist: 200, stunDuration: 0.4 },
            'brute': { size: 30, color: '#ff4d4d', hp: 60, maxHp: 70, speed: 110, damage: 20, xp: 20, slamDamage: 30, stunDuration: 0.6 },
            'mage':  { size: 22, color: '#be4dff', hp: 25, maxHp:30, speed: 120, damage: 8, xp: 15, stunDuration: 0.5 },

            // Inimigos Avan√ßados (Onda 10+)
            'wraith': { size: 20, color: '#a2a2d0', hp: 50, maxHp: 60, speed: 280, damage: 15, xp: 20, stunDuration: 0.5 },
            'crystal_golem': { size: 35, color: '#87cefa', hp: 150, maxHp: 170, speed: 80, damage: 17, xp: 25, stunDuration: 0.1 },
            'abyss_worm': { size: 25, color: '#663399', hp: 100, maxHp: 120, speed: 400, damage: 20, xp: 17, stunDuration: 0.3 },
            'arcane_sentry': { size: 28, color: '#ffdf00', hp: 120, maxHp: 150, speed: 0, damage: 12, xp: 25, stunDuration: 0 },

            // Chefes
            'spectral_elder': { name: 'Anci√£o Espectral', hp: 6000, size: 80, xp: 500},
            'magma_colossus': { name: 'Colosso de Magma', hp: 12000, size: 120, xp: 1000},
            'lava_spawn': { hp: 50, size: 15, speed: 200, damage: 15, xp: 1 }
        },
        WEAPONS: {
            'fireball': { name: 'Bola de Fogo', desc: 'Dispara uma bola de fogo que perfura inimigos.', cooldown: 0.9, damage: 13, speed: 450, pierce: 1, size: 8, color: '#ff8c1a', cost: 0, initialRange: 400 },
            'hammer': { name: 'Martelo Girat√≥rio', desc: 'Um martelo que gira ao seu redor.', cooldown: 0.2, damage: 16, radius: 80, rotationSpeed: 4, size: 20, count: 1, color: '#cccccc', cost: 150 },
            'lightning_chain': { name: 'Corrente El√©trica', desc: 'Raio que salta entre inimigos. Dano reduzido a cada salto.', cooldown: 1.3, damage: 12, chains: 2, chainRadius: 125, damageFalloff: 0.75, initialRange: 400, color: '#4dffff', cost: 300 },
            // Novas Armas (desbloque√°veis)
            'spectral_blades': { name: 'L√¢minas Espectrais', desc: 'Corta inimigos em um arco r√°pido √† sua frente.', cooldown: 0.4, damage: 12, range: 100, arc: Math.PI / 2, count: 2, color: '#aaffff', cost: 500 },
            'singularity_cannon': { name: 'Canh√£o de Singularidade', desc: 'Dispara um orbe que atrai inimigos antes de explodir.', cooldown: 3.5, damage: 28, speed: 150, size: 15, pullRadius: 200, explosionRadius: 150, color: '#9400d3', cost: 800 },
            'runic_orb': { name: 'Orbe R√∫nico', desc: 'Um orbe passivo que atira proj√©teis teleguiados.', cooldown: 0.9, damage: 15, speed: 300, size: 6, color: '#ff69b4', cost: 650 },
        },
        PERMANENT_UPGRADES: {
            'hp_boost': { name: 'Vitalidade', desc: 'Aumenta a vida m√°xima inicial em 5%.', maxLevel: 20, cost: l => 5 + l * 5, format: v => `+${v * 5}% HP` },
            'speed_boost': { name: 'Agilidade', desc: 'Aumenta a velocidade inicial em 3%.', maxLevel: 10, cost: l => 10 + l * 10, format: v => `+${v * 3}% Vel.` },
            'damage_boost': { name: 'For√ßa', desc: 'Aumenta o dano inicial em 5%.', maxLevel: 20, cost: l => 8 + l * 8, format: v => `+${v * 5}% Dano` },
            'greed_boost': { name: 'Sorte', desc: 'Aumenta a chance de Gemas em 1%.', maxLevel: 10, cost: l => 20 + l * 20, format: v => `+${v}% Chance` },
        },
        QUESTS: {
            easy: [
                { id: 'play_1_game', desc: 'Jogue sua primeira partida.', stat: 'gamesPlayed', target: 1, reward: 25 },
                { id: 'kill_100_slimes', desc: 'Derrote 500 Slimes.', stat: 'slime_defeated', target: 500, reward: 50 },
                { id: 'collect_250_gems', desc: 'Colete 300 gemas no total.', stat: 'gemsCollected', target: 300, reward: 75 },
                { id: 'reach_level_10', desc: 'Atinja o n√≠vel 10 em uma partida.', stat: 'maxLevelReached', target: 10, reward: 40 },
                { id: 'survive_5_min', desc: 'Sobreviva por 5 minutos.', stat: 'maxTimeSurvived', target: 300, reward: 60 },
            ],
            medium: [
                { id: 'kill_500_enemies', desc: 'Derrote 1000 inimigos no total.', stat: 'totalEnemiesDefeated', target: 1000, reward: 150 },
                { id: 'kill_250_bats', desc: 'Derrote 400 Morcegos.', stat: 'bat_defeated', target: 400, reward: 125 },
                { id: 'deal_100k_damage', desc: 'Cause 2,500,000 de dano total.', stat: 'totalDamageDealt', target: 2500000, reward: 200 },
                { id: 'collect_1000_gems', desc: 'Colete 1000 gemas no total.', stat: 'gemsCollected', target: 1000, reward: 180 },
                { id: 'buy_5_upgrades', desc: 'Compre 10 melhorias permanentes.', stat: 'upgradesPurchased', target: 10, reward: 100 },
            ],
            hard: [
                { id: 'kill_100_brutes', desc: 'Derrote 200 Brutos.', stat: 'brute_defeated', target: 200, reward: 250 },
                { id: 'kill_75_mages', desc: 'Derrote 150 Magos.', stat: 'mage_defeated', target: 150, reward: 150 },
                { id: 'reach_wave_10', desc: 'Sobreviva at√© a onda 10.', stat: 'maxWaveReached', target: 10, reward: 200 },
                { id: 'evolve_weapon', desc: 'Evolua uma arma pela primeira vez.', stat: 'weaponsEvolved', target: 1, reward: 400 },
                { id: 'defeat_spectral_elder', desc: 'Derrote o Anci√£o Espectral.', stat: 'spectral_elder_defeated', target: 1, reward: 500 },
            ]
        },
        GENERAL_ABILITIES: [
            { id: 'hp_boost', name: 'Vigor', desc: 'Aumenta a vida m√°xima em 12%.', max: 5, 
              apply: p => { 
                const oldMaxHp = p.maxHp;
                p.maxHp *= 1.12;
                p.hp += p.maxHp - oldMaxHp;
              }
            },
            { id: 'speed_boost', name: 'P√©s Ligeiros', desc: 'Aumenta a velocidade em 2%.', max: 5, apply: p => { p.speed *= 1.02; }},
            { 
              id: 'health_regen', name: 'Regenera√ß√£o', 
              desc: [
                  'Recupera 1 HP a cada 3 segundos.',
                  'Recupera 1 HP a cada 2 segundos.',
                  'Recupera 1 HP por segundo.',
              ],
              max: 3, 
              apply: p => { 
                const level = p.abilityLevels['health_regen'] || 1;
                const regenValues = [1/3, 0.5, 1];
                p.regen = regenValues[level - 1];
              }
            },
        ],
        WEAPON_UPGRADES: {
            fireball: [
                { id: 'fireball_damage', name: 'Dano de Fogo +20%', desc: 'Aumenta o dano base da Bola de Fogo.', max: 5, apply: p => p.weapon.stats.damage *= 1.2 },
                { id: 'fireball_cooldown', name: 'Recarga de Fogo -10%', desc: 'Dispara Bolas de Fogo com mais frequ√™ncia.', max: 4, apply: p => p.weapon.stats.cooldown *= 0.9 },
                { id: 'fireball_size', name: 'Tamanho do Fogo +20%', desc: 'Aumenta a √°rea do proj√©til da Bola de Fogo.', max: 4, apply: p => p.weapon.stats.size *= 1.2 },
                { id: 'fireball_pierce', name: '+1 Perfura√ß√£o de Fogo', desc: 'Proj√©teis da Bola de Fogo atingem mais inimigos.', max: 2, apply: p => p.weapon.stats.pierce++ },
            ],
            hammer: [
                { id: 'hammer_damage', name: 'Dano do Martelo +25%', desc: 'Aumenta o dano base do Martelo Girat√≥rio.', max: 5, apply: p => p.weapon.stats.damage *= 1.25 },
                { id: 'hammer_radius', name: 'Raio do Martelo +15%', desc: 'Aumenta o alcance do Martelo Girat√≥rio.', max: 3, apply: p => p.weapon.stats.radius *= 1.15 },
                { id: 'hammer_count', name: '+1 Martelo', desc: 'Adiciona um Martelo Girat√≥rio extra.', max: 1, apply: p => { p.weapon.stats.count++; p.weapon.addHammer(); } },
                { id: 'hammer_rotation_speed', name: 'Velocidade do Martelo +15%', desc: 'Martelos Girat√≥rios giram mais r√°pido.', max: 4, apply: p => p.weapon.stats.rotationSpeed *= 1.15 },
                { id: 'hammer_size', name: 'Tamanho do Martelo +15%', desc: 'Aumenta a √°rea de acerto do Martelo Girat√≥rio.', max: 4, apply: p => p.weapon.stats.size *= 1.15 },
            ],
            lightning_chain: [
                { id: 'lightning_damage', name: 'Alta Tens√£o +25%', desc: 'Aumenta o dano base do raio.', max: 5, apply: p => p.weapon.stats.damage *= 1.25 },
                { id: 'lightning_cooldown', name: 'Recarga El√©trica -12%', desc: 'Dispara raios com mais frequ√™ncia.', max: 4, apply: p => p.weapon.stats.cooldown *= 0.88 },
                { id: 'lightning_chains', name: 'Condutividade +1', desc: 'O raio atinge +1 inimigo.', max: 4, apply: p => p.weapon.stats.chains++ },
                { id: 'lightning_radius', name: 'Alcance do Salto +25%', desc: 'O raio pode saltar para inimigos mais distantes.', max: 3, apply: p => p.weapon.stats.chainRadius *= 1.25 },
                { id: 'lightning_range', name: 'Alcance Inicial +20%', desc: 'Aumenta o alcance para atingir o primeiro alvo.', max: 3, apply: p => p.weapon.stats.initialRange *= 1.20 }
            ],
            spectral_blades: [
                { id: 'sb_damage', name: 'Dano Espectral +20%', desc: 'Aumenta o dano das l√¢minas.', max: 5, apply: p => p.weapon.stats.damage *= 1.2 },
                { id: 'sb_cooldown', name: 'Recarga Espectral -10%', desc: 'Ataca com mais frequ√™ncia.', max: 4, apply: p => p.weapon.stats.cooldown *= 0.9 },
                { id: 'sb_range', name: 'Alcance Espectral +15%', desc: 'Aumenta o alcance do corte.', max: 3, apply: p => p.weapon.stats.range *= 1.15 },
                { id: 'sb_arc', name: 'Arco Espectral +20¬∞', desc: 'Aumenta a √°rea do corte.', max: 3, apply: p => p.weapon.stats.arc += Math.PI / 9 },
            ],
            singularity_cannon: [
                { id: 'sc_damage', name: 'Dano de Singularidade +20%', desc: 'Aumenta o dano da explos√£o.', max: 5, apply: p => p.weapon.stats.damage *= 1.2 },
                { id: 'sc_cooldown', name: 'Recarga de Singularidade -10%', desc: 'Dispara com mais frequ√™ncia.', max: 4, apply: p => p.weapon.stats.cooldown *= 0.9 },
                { id: 'sc_radius', name: 'Raio de Efeito +20%', desc: 'Aumenta o raio de atra√ß√£o e explos√£o.', max: 4, apply: p => { p.weapon.stats.pullRadius *= 1.2; p.weapon.stats.explosionRadius *= 1.2; } },
            ],
            runic_orb: [
                { id: 'ro_damage', name: 'Dano R√∫nico +25%', desc: 'Aumenta o dano dos proj√©teis.', max: 5, apply: p => p.weapon.stats.damage *= 1.25 },
                { id: 'ro_cooldown', name: 'Recarga R√∫nica -12%', desc: 'O orbe dispara mais r√°pido.', max: 4, apply: p => p.weapon.stats.cooldown *= 0.88 },
                { id: 'ro_speed', name: 'Velocidade R√∫nica +20%', desc: 'Proj√©teis r√∫nicos mais r√°pidos.', max: 3, apply: p => p.weapon.stats.speed *= 1.2 },
            ],
        },
        WEAPON_EVOLUTIONS: {
            fireball: {
                id: 'evolve_fireball', name: 'EVOLUIR: SUPERNOVA',
                desc: 'Conjura um trio de bolas de fogo massivas que explodem ao atingir o limite.',
                requires: ['fireball_damage', 'fireball_cooldown', 'fireball_size', 'fireball_pierce'],
                apply: p => p.weapon.evolve()
            },
            hammer: {
                id: 'evolve_hammer', name: 'EVOLUIR: MARTELO JUSTICEIRO',
                desc: 'Os martelos se tornam gigantes e liberam ondas de choque devastadoras.',
                requires: ['hammer_damage', 'hammer_radius', 'hammer_count', 'hammer_rotation_speed', 'hammer_size'],
                apply: p => p.weapon.evolve()
            },
            lightning_chain: {
                id: 'evolve_lightning', name: 'EVOLUIR: TEMPESTADE EST√ÅTICA',
                desc: 'Atinge todos os alvos instantaneamente, sempre os atordoa e n√£o perde mais dano por salto.',
                requires: ['lightning_damage', 'lightning_cooldown', 'lightning_chains', 'lightning_radius', 'lightning_range'],
                apply: p => p.weapon.evolve()
            },
            spectral_blades: {
                id: 'evolve_sb', name: 'EVOLUIR: DAN√áA FANTASMA',
                desc: 'Cria uma tempestade de l√¢minas em 360¬∞ ao seu redor.',
                requires: ['sb_damage', 'sb_cooldown', 'sb_range', 'sb_arc'],
                apply: p => p.weapon.evolve()
            },
            singularity_cannon: {
                id: 'evolve_sc', name: 'EVOLUIR: EMISSOR DE BURACO NEGRO',
                desc: 'A singularidade dura mais, puxa mais forte e causa uma explos√£o catacl√≠smica.',
                requires: ['sc_damage', 'sc_cooldown', 'sc_radius'],
                apply: p => p.weapon.evolve()
            },
            runic_orb: {
                id: 'evolve_ro', name: 'EVOLUIR: OLHO DO ARCONTE',
                desc: 'Adiciona um segundo orbe e ambos disparam proj√©teis perfurantes.',
                requires: ['ro_damage', 'ro_cooldown', 'ro_speed'],
                apply: p => p.weapon.evolve()
            },
        },
        PETS: {
            'wisp': { name: 'Fogo-F√°tuo', desc: 'Um esp√≠rito de fogo que ataca inimigos com proj√©teis teleguiados.', baseCooldown: 1.8, baseDamage: 8 },
            'golem': { name: 'Golem de Pedra', desc: 'Um protetor que periodicamente concede um escudo que bloqueia dano.', baseCooldown: 15, baseShieldHits: 1 },
            'sprite': { name: 'Sprite El√©trico', desc: 'Uma centelha de energia que atordoa o inimigo mais pr√≥ximo.', baseCooldown: 6, baseStun: 1.0 },
            'sprout': { name: 'Brotinho Nutriente', desc: 'Uma pequena planta que gera orbes de cura para o jogador.', baseCooldown: 10, baseHeal: 5 },
            'shadow_pup': { name: 'C√£o Sombrio', desc: 'Um fiel c√£ozinho que aumenta seu raio de coleta de orbes e gemas.', baseRadius: 1.5 },
        },
        PET_UPGRADES: [
            // Upgrades do Fogo-F√°tuo
            { id: 'pet_wisp_damage', name: 'Alma Ardente', desc: 'Aumenta o dano do Fogo-F√°tuo em 25%.', max: 3, for: ['wisp'], apply: p => p.pet.damageMultiplier = 1 + 0.25 * p.abilityLevels['pet_wisp_damage'] },
            { id: 'pet_wisp_cooldown', name: 'Chama Eterna', desc: 'O Fogo-F√°tuo ataca 20% mais r√°pido.', max: 2, for: ['wisp'], apply: p => p.pet.cooldownMultiplier = 1 - 0.2 * p.abilityLevels['pet_wisp_cooldown'] },
            // Upgrades do Golem
            { id: 'pet_golem_cooldown', name: 'Guardi√£o Leal', desc: 'O Golem de Pedra gera escudos 25% mais r√°pido.', max: 2, for: ['golem'], apply: p => p.pet.cooldownMultiplier = 1 - 0.25 * p.abilityLevels['pet_golem_cooldown'] },
            { id: 'pet_golem_hits', name: 'Barreira Refor√ßada', desc: 'O escudo do Golem agora absorve 1 golpe extra.', max: 2, for: ['golem'], apply: p => p.pet.shieldHits = 1 + p.abilityLevels['pet_golem_hits'] },
             // Upgrades do Sprite
            { id: 'pet_sprite_cooldown', name: 'Supercondutor', desc: 'O Sprite El√©trico atordoa 25% mais r√°pido.', max: 2, for: ['sprite'], apply: p => p.pet.cooldownMultiplier = 1 - 0.25 * p.abilityLevels['pet_sprite_cooldown'] },
            { id: 'pet_sprite_stun', name: 'Choque de Alta Voltagem', desc: 'Aumenta a dura√ß√£o do atordoamento em 50%.', max: 2, for: ['sprite'], apply: p => p.pet.stunDurationMultiplier = 1 + 0.5 * p.abilityLevels['pet_sprite_stun'] },
             // Upgrades do Brotinho
            { id: 'pet_sprout_cooldown', name: 'Fotoss√≠ntese R√°pida', desc: 'O Brotinho gera orbes de cura 20% mais r√°pido.', max: 2, for: ['sprout'], apply: p => p.pet.cooldownMultiplier = 1 - 0.2 * p.abilityLevels['pet_sprout_cooldown'] },
            { id: 'pet_sprout_heal', name: 'N√©ctar Potente', desc: 'Aumenta a cura dos orbes em 50%.', max: 3, for: ['sprout'], apply: p => p.pet.healMultiplier = 1 + 0.5 * p.abilityLevels['pet_sprout_heal'] },
             // Upgrades do C√£o
            { id: 'pet_pup_radius', name: 'Faro Agu√ßado', desc: 'Aumenta ainda mais o b√¥nus de coleta do C√£o Sombrio.', max: 3, for: ['shadow_pup'], apply: p => p.pet.radiusMultiplier = CONFIG.PETS.shadow_pup.baseRadius + 0.25 * p.abilityLevels['pet_pup_radius'] },
        ],
        GRAPHICS: {
            'low':    { particleMultiplier: 0.2, shadows: false, ambientParticles: 20 },
            'medium': { particleMultiplier: 0.6, shadows: true,  ambientParticles: 80 },
            'high':   { particleMultiplier: 1.0, shadows: true,  ambientParticles: 200 }
        }
    };
        // --- Gerenciador de Som ---
  // --- Gerenciador de Som ---
    class SoundManager {
        constructor() {
            this.isInitialized = false; this.synths = {}; this.initPromise = null;
            this.hitPlayedThisFrame = false;
        }
        async init() {
            if (this.initPromise) return this.initPromise;
            this.initPromise = (async () => {
                if (this.isInitialized || typeof Tone === 'undefined') return;
                try {
                    await Tone.start();
                    this.synths = {
                        shot: { synth: new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.005, decay: 0.05, sustain: 0, release: 0.1 }}).toDestination(), baseVolume: -15 },
                        hit: { synth: new Tone.MembraneSynth({ pitchDecay: 0.08, octaves: 4, envelope: { attack: 0.001, decay: 0.2, sustain: 0 }}).toDestination(), baseVolume: -10 },
                        dash: { synth: new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.01, decay: 0.15, sustain: 0 }}).toDestination(), baseVolume: -20 },
                        collect: { synth: new Tone.PluckSynth({ attackNoise: 0.5, dampening: 4000, resonance: 0.7 }).toDestination(), baseVolume: -15 },
                        levelUp: { synth: new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'triangle8' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.5 }}).toDestination(), baseVolume: -10 },
                        gameOver: { synth: new Tone.Synth({ oscillator: { type: 'sawtooth' }, envelope: { attack: 0.1, decay: 0.8, sustain: 0.1, release: 1 }}).toDestination(), baseVolume: -10 },
                        buy: { synth: new Tone.MetalSynth({ frequency: 200, envelope: { attack: 0.001, decay: 0.4, release: 0.2 }, harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5 }).toDestination(), baseVolume: -20 },
                        uiClick: { synth: new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 2, envelope: { attack: 0.001, decay: 0.15, sustain: 0 }}).toDestination(), baseVolume: -15 },
                        // NOVOS EFEITOS SONOROS
                        parry: { synth: new Tone.MetalSynth({ frequency: 400, envelope: { attack: 0.001, decay: 0.1, release: 0.1 }, harmonicity: 3.1, modulationIndex: 16, resonance: 2000, octaves: 1.5 }).toDestination(), baseVolume: -12 },
                        push: { synth: new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 }}).toDestination(), baseVolume: -10 },
                    };
                    this.isInitialized = true;
                    this.setMasterVolume(playerData.audio.masterVolume);
                } catch (e) { console.error("Erro ao inicializar o √°udio:", e); }
            })();
            return this.initPromise;
        }
        play(sound) {
            if (sound === 'hit' && this.hitPlayedThisFrame) return;
            if (!this.isInitialized || !this.synths[sound]) return;
            const { synth, baseVolume } = this.synths[sound];
            const sfxGain = playerData.audio.sfxVolume;
            const finalVolume = baseVolume + (sfxGain > 0.01 ? Tone.gainToDb(sfxGain) : -Infinity);
            synth.volume.value = finalVolume;
            try {
                switch (sound) {
                    case 'shot': synth.triggerAttackRelease('G5', '16n'); break;
                    case 'hit': synth.triggerAttackRelease('C2', '8n'); break;
                    case 'dash': synth.triggerAttackRelease('0.1'); break;
                    case 'collect': synth.triggerAttackRelease('C5', '8n'); break;
                    case 'levelUp': synth.triggerAttackRelease(['C4', 'E4', 'G4', 'C5'], '0.4'); break;
                    case 'gameOver': synth.triggerAttackRelease('C3', '0.8'); break;
                    case 'buy': synth.triggerAttackRelease('C4', '8n', undefined, 0.8); break;
                    case 'uiClick': synth.triggerAttackRelease('C3', '16n'); break;
                    // NOVOS TRIGGERS
                    case 'parry': synth.triggerAttackRelease('C5', '16n'); break;
                    case 'push': synth.triggerAttackRelease('0.2'); break;
                }
            } catch (e) {}
            if (sound === 'hit') this.hitPlayedThisFrame = true;
        }
        reset() { this.hitPlayedThisFrame = false; }
        setMasterVolume(level) {
            if (this.isInitialized) {
                Tone.Master.volume.value = level > 0.01 ? Tone.gainToDb(level) : -Infinity;
            }
        }
    }
        // --- Classes de Entidades do Jogo ---
    class Camera {
        constructor(target) {
            this.target = target;
            this.zoom = 1;
            this.targetZoom = 1;
            this.x = 0;
            this.y = 0;
            this.shakeDuration = 0;
            this.shakeIntensity = 0;
            this.updateZoom();
        }
        updateZoom() {
            if (isMobile) {
                this.targetZoom = 0.7;
            } else {
                this.targetZoom = 1.0;
            }
        }
        update() {
            this.zoom += (this.targetZoom - this.zoom) * 0.05;
            const lerpFactor = 0.1;
            this.x += (this.target.x - this.x) * lerpFactor;
            this.y += (this.target.y - this.y) * lerpFactor;
            const visibleWidth = screenWidth / this.zoom;
            const visibleHeight = screenHeight / this.zoom;
            this.x = Math.max(visibleWidth / 2, Math.min(this.x, CONFIG.MAP_SIZE.width - visibleWidth / 2));
            this.y = Math.max(visibleHeight / 2, Math.min(this.y, CONFIG.MAP_SIZE.height - visibleHeight / 2));
            if (this.shakeDuration > 0) this.shakeDuration -= 1 / 60;
        }
        apply(context) {
            context.save();
            let shakeX = 0, shakeY = 0;
            if (this.shakeDuration > 0) {
                shakeX = (Math.random() - 0.5) * this.shakeIntensity;
                shakeY = (Math.random() - 0.5) * this.shakeIntensity;
            }
            context.translate(screenWidth / 2, screenHeight / 2);
            context.scale(this.zoom, this.zoom);
            context.translate(-this.x + shakeX, -this.y + shakeY);
        }
        restore(context) { context.restore(); }
        startShake(intensity, duration) {
            if (!playerData.graphics.screenShake) return;
            this.shakeIntensity = intensity;
            this.shakeDuration = duration;
        }
    }

class Player {
        constructor() {
            this.x = CONFIG.MAP_SIZE.width / 2;
            this.y = CONFIG.MAP_SIZE.height / 2;
            this.size = CONFIG.PLAYER.size;
            this.maxHp = CONFIG.PLAYER.baseMaxHp * (1 + (playerData.purchasedUpgrades['hp_boost'] || 0) * 0.05);
            this.hp = this.maxHp;
            this.speed = CONFIG.PLAYER.baseSpeed * (1 + (playerData.purchasedUpgrades['speed_boost'] || 0) * 0.03);
            this.damageMultiplier = 1 + (playerData.purchasedUpgrades['damage_boost'] || 0) * 0.05;
            this.level = 1; this.xp = 0; this.xpToNextLevel = 10;
            this.regen = 0;
            this.invincibilityTimer = 0;
            this.stunTimer = 0;
            this.lastMoveDirection = { x: 0, y: 1 };
            this.weaponUpgradeLuck = 0;
            this.isMoving = false;
            this.fragments = [];
            this.orbitalAngle = 0;
            this.isAlive = true;
            this.rerollCost = 5;
            this.pickupRadius = CONFIG.PLAYER.basePickupRadius;
            this.pickupRadiusMultiplier = 1;
            this.pet = null;
            this.stepTimer = 0;

            // Habilidades Ativas
            this.isDashing = false;
            this.dashCooldown = 0;
            this.dashDirection = { x: 0, y: 0 };
            this.isParrying = false;
            this.parryTimer = 0;
            this.parryCooldown = 0;
            this.parriedEnemies = []; // Lista de inimigos j√° aparados
            this.pushCooldown = 0;

            // Buffs de Santu√°rio
            this.furyShrineTimer = 0;
            this.protectionShrineTimer = 0;
            this.wealthShrineTimer = 0;

            for (let i = 0; i < 4; i++) {
                this.fragments.push({
                    size: 8 + Math.random() * 4,
                    angle: (Math.PI / 2) * i, 
                    targetAngle: (Math.PI / 2) * i,
                    distance: this.size * 1.8, 
                    targetDistance: this.size * 1.8,
                    rotation: 0,
                    rotationSpeed: (Math.random() - 0.5) * 4
                });
            }
            switch (playerData.equippedWeapon) {
                case 'hammer': this.weapon = new HammerWeapon(this); break;
                case 'lightning_chain': this.weapon = new LightningChainWeapon(this); break;
                case 'spectral_blades': this.weapon = new SpectralBladesWeapon(this); break;
                case 'singularity_cannon': this.weapon = new SingularityCannonWeapon(this); break;
                case 'runic_orb': this.weapon = new RunicOrbWeapon(this); break;
                case 'fireball': default: this.weapon = new FireballWeapon(this); break;
            }
            this.abilityLevels = {};
        }

        update(dt) {
            this.handleMovement(dt);
            this.weapon.update(dt);
            if (this.pet) { this.pet.update(dt); }

            // Cooldowns e Timers
            if (this.dashCooldown > 0) this.dashCooldown -= dt;
            if (this.parryCooldown > 0) this.parryCooldown -= dt;
            if (this.pushCooldown > 0) this.pushCooldown -= dt;
            if (this.parryTimer > 0) {
                this.parryTimer -= dt;
                if (this.parryTimer <= 0) this.isParrying = false;
            }
            if (this.invincibilityTimer > 0) this.invincibilityTimer -= dt;
            if (this.protectionShrineTimer > 0) this.protectionShrineTimer -= dt;
            if (this.furyShrineTimer > 0) this.furyShrineTimer -= dt;
            if (this.wealthShrineTimer > 0) this.wealthShrineTimer -= dt;
            if (this.stunTimer > 0) {
                this.stunTimer -= dt;
                return; 
            }
            if (this.regen > 0 && this.hp < this.maxHp) {
                this.hp = Math.min(this.maxHp, this.hp + this.regen * dt);
            }

            // Anima√ß√£o dos fragmentos
            this.orbitalAngle += 1.5 * dt; 
            const lerpFactor = dt * 8;
            const moveAngle = Math.atan2(this.lastMoveDirection.y, this.lastMoveDirection.x);
            this.fragments.forEach((frag, i) => {
                if (this.isDashing) {
                    frag.targetDistance = this.size * 0.8 + i * 5;
                    frag.targetAngle = Math.atan2(-this.dashDirection.y, -this.dashDirection.x);
                } else if (this.isParrying) {
                    frag.targetDistance = this.size * 1.2;
                    frag.targetAngle = this.orbitalAngle * 2 + (Math.PI / 2) * i;
                } else if (this.isMoving) {
                    frag.targetDistance = this.size * 1.5 + i * 3;
                    frag.targetAngle = moveAngle + Math.PI; 
                } else {
                    frag.targetDistance = this.size * 1.8;
                    frag.targetAngle = this.orbitalAngle + (Math.PI / 2) * i; 
                }
                frag.distance += (frag.targetDistance - frag.distance) * lerpFactor;
                let angleDiff = frag.targetAngle - frag.angle;
                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                frag.angle += angleDiff * lerpFactor;
                frag.rotation += frag.rotationSpeed * dt;
            });
        }

        handleMovement(dt) {
            if (this.isDashing) {
                this.x += this.dashDirection.x * CONFIG.PLAYER.dashSpeed * dt;
                this.y += this.dashDirection.y * CONFIG.PLAYER.dashSpeed * dt;
                createParticleBurst(this.x, this.y, 1, 'rgba(255, 255, 255, 0.5)', 0.2, 2, 100);
                return;
            }
            let move = { x: joystickVector.x, y: joystickVector.y };
            if (keys['w'] || keys['arrowup']) move.y = -1;
            if (keys['s'] || keys['arrowdown']) move.y = 1;
            if (keys['a'] || keys['arrowleft']) move.x = -1;
            if (keys['d'] || keys['arrowright']) move.x = 1;
            this.isMoving = move.x !== 0 || move.y !== 0;
            if (this.isMoving) {
                const mag = Math.sqrt(move.x**2 + move.y**2);
                if (mag > 0) { move.x /= mag; move.y /= mag; }
                this.lastMoveDirection = { ...move };
                this.x += move.x * this.speed * dt;
                this.y += move.y * this.speed * dt;
                this.stepTimer -= dt;
                if (this.stepTimer <= 0) {
                    this.stepTimer = 0.2;
                    const particleX = this.x - move.x * (this.size * 0.5);
                    const particleY = this.y - move.y * (this.size * 0.5);
                    createParticleBurst(particleX, particleY, 1, 'rgba(255, 255, 255, 0.3)', 0.3, 2, 50);
                }
            }
            this.x = Math.max(this.size, Math.min(this.x, CONFIG.MAP_SIZE.width - this.size));
            this.y = Math.max(this.size, Math.min(this.y, CONFIG.MAP_SIZE.height - this.size));
        }

draw(ctx) {
            // Auras de Buffs
            ctx.save();
            ctx.globalAlpha = 0.4 * playerData.graphics.effectsOpacity;
            const pulse = 1 + Math.sin(gameTime * 10) * 0.1;
            if (this.protectionShrineTimer > 0) {
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 1.2 * pulse, 0, Math.PI * 2);
                ctx.fill();
            }
            if (this.furyShrineTimer > 0) {
                ctx.fillStyle = '#ff4d4d';
                 ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 1.4 * pulse, 0, Math.PI * 2);
                ctx.fill();
            }
            if (this.wealthShrineTimer > 0) {
                 ctx.fillStyle = '#ffff4d';
                 ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 1.6 * pulse, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();

            let playerColor = '#8a8aff';
            if (this.invincibilityTimer > 0 || this.protectionShrineTimer > 0) playerColor = 'rgba(200, 200, 255, 0.7)';
            if (this.stunTimer > 0) playerColor = '#ffff99';
            ctx.save();
            if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = playerColor;
            }

            // --- IN√çCIO DA L√ìGICA DE DESENHO DOS FRAGMENTOS E CORRENTES ---
            this.fragments.forEach(frag => {
                const fragX = this.x + Math.cos(frag.angle) * frag.distance;
                const fragY = this.y + Math.sin(frag.angle) * frag.distance;

                // --- NOVO: L√ìGICA DA CORRENTE EL√âTRICA ---
                ctx.save();
                const dx = this.x - fragX;
                const dy = this.y - fragY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const normal = { x: -dy / dist, y: dx / dist }; // Vetor perpendicular

                ctx.strokeStyle = `rgba(170, 220, 255, ${0.4 + Math.sin(gameTime * 20) * 0.3})`;
                ctx.lineWidth = 1.5;
                if (currentGraphics && currentGraphics.shadows) {
                    ctx.shadowColor = '#4dffff';
                    ctx.shadowBlur = 10;
                }

                ctx.beginPath();
                ctx.moveTo(fragX, fragY);
                // Desenha a linha em segmentos "quebrados"
                for (let i = 1; i < 4; i++) {
                    const t = i / 4;
                    const pointX = fragX + dx * t;
                    const pointY = fragY + dy * t;
                    const offset = (Math.random() - 0.5) * 8 * Math.sin(t * Math.PI);
                    ctx.lineTo(pointX + normal.x * offset, pointY + normal.y * offset);
                }
                ctx.lineTo(this.x, this.y);
                ctx.stroke();
                ctx.restore();
                // --- FIM DA L√ìGICA DA CORRENTE EL√âTRICA ---


                // L√≥gica original para desenhar o fragmento
                ctx.save();
                ctx.translate(fragX, fragY);
                ctx.rotate(frag.rotation);
                ctx.fillStyle = playerColor;
                if (currentGraphics && currentGraphics.shadows) ctx.shadowBlur = 10;
                ctx.fillRect(-frag.size / 2, -frag.size / 2, frag.size, frag.size);
                ctx.restore();
            });
            // --- FIM DA L√ìGICA DE DESENHO DOS FRAGMENTOS E CORRENTES ---


            // L√≥gica original para desenhar o corpo do jogador
            ctx.fillStyle = playerColor;
            if (currentGraphics && currentGraphics.shadows) ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size / 1.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            if (currentGraphics && currentGraphics.shadows) ctx.shadowBlur = 0;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size / 3, 0, Math.PI * 2);
            ctx.fill();
            if (this.stunTimer > 0) {
                ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';
                ctx.font = '10px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText("STUN", this.x, this.y - this.size * 1.5);
            }
            ctx.restore();
        }

        dash() {
            if (this.dashCooldown > 0 || this.isDashing || gameState !== 'playing' || this.stunTimer > 0) return;
            this.isDashing = true;
            this.dashCooldown = CONFIG.PLAYER.dashCooldown;
            soundManager.play('dash');
            let move = { x: joystickVector.x, y: joystickVector.y };
            if (keys['w'] || keys['arrowup']) move.y = -1; if (keys['s'] || keys['arrowdown']) move.y = 1;
            if (keys['a'] || keys['arrowleft']) move.x = -1; if (keys['d'] || keys['arrowright']) move.x = 1;
            this.dashDirection = (move.x !== 0 || move.y !== 0) ? 
                normalizeVector(move) : { ...this.lastMoveDirection };
            setTimeout(() => { this.isDashing = false; }, CONFIG.PLAYER.dashDuration * 1000);
        }

        activateParry() {
            if (this.parryCooldown > 0 || gameState !== 'playing' || this.stunTimer > 0) return;
            this.isParrying = true;
            this.parryTimer = CONFIG.PLAYER.parryDuration;
            this.parryCooldown = CONFIG.PLAYER.parryCooldown;
            this.parriedEnemies = []; // Limpa a lista de inimigos a cada novo parry
            // Efeito visual sutil na ATIVA√á√ÉO, sem som
            createParticleBurst(this.x, this.y, 10, 'rgba(200, 220, 255, 0.7)', 0.2, 3, -100);
        }

        activatePush() {
            if (this.pushCooldown > 0 || gameState !== 'playing' || this.stunTimer > 0) return;
            this.pushCooldown = CONFIG.PLAYER.pushCooldown;
            soundManager.play('push');
            effects.push(new PushWaveEffect(this.x, this.y, CONFIG.PLAYER.pushRadius));
            enemies.forEach(enemy => {
                const dx = enemy.x - this.x;
                const dy = enemy.y - this.y;
                const distSq = dx * dx + dy * dy;
                if (distSq < CONFIG.PLAYER.pushRadius ** 2) {
                    enemy.takeDamage(CONFIG.PLAYER.pushDamage * this.damageMultiplier);
                    if (distSq > 0 && !enemy.isBoss) {
                        const dist = Math.sqrt(distSq);
                        enemy.x += (dx / dist) * CONFIG.PLAYER.pushForce / dist;
                        enemy.y += (dy / dist) * CONFIG.PLAYER.pushForce / dist;
                        enemy.applyStun(0.3);
                    }
                }
            });
        }

        takeDamage(amount) {
            if (this.isParrying || this.invincibilityTimer > 0 || this.protectionShrineTimer > 0) return;
            if(this.pet && this.pet.id === 'golem' && this.pet.shieldActive) {
                this.pet.shieldHitsLeft--;
                if(this.pet.shieldHitsLeft <= 0) {
                    this.pet.shieldActive = false;
                }
                floatingTexts.push(new FloatingText(this.x, this.y - this.size, `BLOQUEADO!`, '#c0c0c0'));
                return;
            }

            this.hp -= amount;
            this.invincibilityTimer = 0.5;
            camera.startShake(8, 0.2);
            floatingTexts.push(new FloatingText(this.x, this.y - this.size, `-${Math.round(amount)}`, '#ff4d4d'));

            if (this.hp <= 0) { 
                this.hp = 0; 
                this.isAlive = false;
                gameOver(); 
            }
        }

        heal(amount) {
            if (this.hp >= this.maxHp) return;
            const realHeal = Math.min(amount, this.maxHp - this.hp);
            this.hp += realHeal;
            floatingTexts.push(new FloatingText(this.x, this.y + this.size, `+${Math.round(realHeal)}`, '#4dff9e'));
        }

        addXp(amount) {
            this.xp += amount;
            if (this.xp >= this.xpToNextLevel) this.levelUp();
        }

        levelUp() {
            while (this.xp >= this.xpToNextLevel) {
                this.xp -= this.xpToNextLevel;
                this.level++;
                this.xpToNextLevel = Math.floor(this.xpToNextLevel * 1.5);
                soundManager.play('levelUp');
                createParticleBurst(this.x, this.y, 30, '#4dff9e', 1, 5, 200);
                showAbilityChoice();
            }
        }

        applyStun(duration) {
            this.stunTimer = Math.max(this.stunTimer, duration);
        }
    }
    class Enemy {
        constructor(x, y, type) {
            this.x = x; this.y = y; this.type = type;
            const config = CONFIG.ENEMY[type];
            this.size = config.size; this.color = config.color;
            this.hp = config.hp; this.maxHp = config.maxHp;
            this.speed = config.speed;
            this.damage = config.damage; this.xpValue = config.xp;
            this.stunDuration = config.stunDuration || 0.5;
            this.flashTimer = 0;
            this.isAlive = true;
            this.meleeAttackRange = this.size / 2 + 5;
            this.isChampion = false;
            this.isBoss = false;
            this.stunTimer = 0;
        }

        update(dt) {
            if (this.stunTimer > 0) {
                this.stunTimer -= dt;
                createParticleBurst(this.x, this.y, 1, '#ffff00', 0.1, 2, 20);
                return;
            }
        }

        makeChampion() {
            this.isChampion = true;
            this.hp *= 3; this.maxHp *= 3; this.damage *= 1.5; this.size *= 1.3;
            this.meleeAttackRange = this.size / 2 + 5;
        }

        takeDamage(amount) {
            if (!this.isAlive) return;
            const finalDamage = Math.round(amount);
            this.hp -= finalDamage;
            runStats.damageDealt += finalDamage;
            this.flashTimer = 0.1;
            floatingTexts.push(new FloatingText(this.x, this.y - this.size / 2, finalDamage, '#ffffff'));
            if (this.hp <= 0) this.die();
        }

        heal(amount) {
            if (!this.isAlive) return;
            this.hp = Math.min(this.maxHp, this.hp + amount);
            floatingTexts.push(new FloatingText(this.x, this.y - this.size, `+${Math.round(amount)}`, '#4dff4d'));
        }

        die() {
            this.isAlive = false;
            runStats.enemiesDefeated++;
            const statKey = `${this.type}_defeated`;
            playerData.persistentStats[statKey] = (playerData.persistentStats[statKey] || 0) + 1;
            playerData.persistentStats.totalEnemiesDefeated = (playerData.persistentStats.totalEnemiesDefeated || 0) + 1;
            createParticleBurst(this.x, this.y, 15, this.color);
            expOrbs.push(new ExpOrb(this.x, this.y, this.xpValue));

            const gemChance = 0.05 + ((playerData.purchasedUpgrades['greed_boost'] || 0) * 0.01);
            if (this.isChampion || (player && player.wealthShrineTimer > 0)) {
                 if(this.isChampion) {
                    for (let i = 0; i < 5; i++) soulGems.push(new SoulGem(this.x + (Math.random() - 0.5) * 20, this.y + (Math.random() - 0.5) * 20));
                 } else {
                    soulGems.push(new SoulGem(this.x, this.y));
                 }
            } else if (Math.random() < gemChance) {
                soulGems.push(new SoulGem(this.x, this.y));
            }

            if (Math.random() < 0.03) {
                 if (Math.random() < 0.5) powerups.push(new HealingFragment(this.x, this.y));
                 else powerups.push(new MagnetFragment(this.x, this.y));
            }
        }

        applyStun() {
            this.stunTimer = this.stunDuration;
        }
    }
        class Slime extends Enemy {
        constructor(x, y) {
            super(x, y, 'slime');
            this.moveState = 'waiting';
            this.jumpCooldown = 1.5;
            this.jumpTimer = Math.random() * this.jumpCooldown;
            this.jumpDuration = 0.3;
            this.jumpProgress = 0;
            this.jumpHeight = 40;
            this.jumpStartX = x; this.jumpStartY = y;
            this.jumpTargetX = x; this.jumpTargetY = y;
            this.scale = { x: 1, y: 1 };
        }
        update(dt) {
            super.update(dt);
            if (this.stunTimer > 0) return;
            if (this.moveState === 'waiting') {
                this.jumpTimer -= dt;
                this.scale.x = Math.max(1, this.scale.x - dt * 4);
                this.scale.y = Math.min(1, this.scale.y + dt * 4);
                if (this.jumpTimer <= 0) this.startJump();
            } else if (this.moveState === 'jumping') {
                this.jumpProgress += dt;
                const t = this.jumpProgress / this.jumpDuration;
                if (t >= 1) {
                    this.x = this.jumpTargetX; this.y = this.jumpTargetY; this.land();
                } else {
                    this.x = this.jumpStartX + (this.jumpTargetX - this.jumpStartX) * t;
                    this.y = this.jumpStartY + (this.jumpTargetY - this.jumpStartY) * t;
                    this.scale.y = 1 + Math.sin(t * Math.PI) * 0.3;
                    this.scale.x = 1 - Math.sin(t * Math.PI) * 0.2;
                }
            }
            if (this.flashTimer > 0) this.flashTimer -= dt;
        }
        startJump() {
            this.moveState = 'jumping'; this.jumpProgress = 0;
            this.jumpStartX = this.x; this.jumpStartY = this.y;
            const dx = player.x - this.x, dy = player.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const jumpDistance = Math.min(dist, this.speed * this.jumpDuration * 1.5);
            if (dist > 0) {
                this.jumpTargetX = this.x + (dx / dist) * jumpDistance;
                this.jumpTargetY = this.y + (dy / dist) * jumpDistance;
            } else {
                this.jumpTargetX = this.x; this.jumpTargetY = this.y;
            }
            createParticleBurst(this.x, this.y, 5, 'rgba(77, 255, 77, 0.5)', 0.3, 2, 50);
        }
        land() {
            this.moveState = 'waiting';
            this.jumpTimer = this.jumpCooldown * (0.5 + Math.random() * 0.3);
            createParticleBurst(this.x, this.y, 10, 'rgba(77, 255, 77, 0.7)', 0.5, 3, 80);
            this.scale.x = 1.4; this.scale.y = 0.6;
        }
        draw(ctx) {
            const width = this.size * this.scale.x, height = this.size * this.scale.y;
            const jumpProgressRatio = this.moveState === 'jumping' ? this.jumpProgress / this.jumpDuration : 0;
            const shadowSize = this.size * 0.8 * (1 - (Math.sin(jumpProgressRatio * Math.PI) * 0.5));
            const shadowYOffset = this.size / 2;
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath();
            ctx.ellipse(this.x, this.y + shadowYOffset, shadowSize, shadowSize / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            const jumpArc = Math.sin(jumpProgressRatio * Math.PI) * this.jumpHeight;
            const drawY = this.y - jumpArc;
            ctx.save();
            ctx.globalAlpha = playerData.graphics.effectsOpacity;
            ctx.fillStyle = this.flashTimer > 0 ? '#ffffff' : (this.stunTimer > 0 ? '#ffff99' : 'rgba(77, 255, 77, 0.8)');
            ctx.strokeStyle = '#28a428'; ctx.lineWidth = 2;
            if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = this.color; ctx.shadowBlur = 10;
            }
            ctx.beginPath();
            ctx.rect(this.x - width / 2, drawY - height / 2, width, height);
            ctx.fill(); ctx.stroke();
            ctx.fillStyle = 'rgba(200, 255, 200, 0.6)';
            ctx.fillRect(this.x - width / 2 + 2, drawY - height / 2 + 2, width - 4, height / 3);
            if (this.isChampion) {
                const glow = Math.abs(Math.sin(gameTime * 5));
                if (currentGraphics && currentGraphics.shadows) {
                    ctx.shadowColor = '#ffd700';
                    ctx.shadowBlur = 15 + glow * 10;
                }
                ctx.strokeStyle = `rgba(255, 215, 0, ${0.5 + glow * 0.5})`;
                ctx.lineWidth = 3;
                ctx.strokeRect(this.x - width / 2, drawY - height / 2, width, height);
            }
            ctx.restore();
        }
    }
    class Bat extends Enemy {
        constructor(x, y) {
            super(x, y, 'bat');
            this.state = 'circling'; this.stateTimer = 0;
            this.diveCooldown = this.getStat('diveCooldown') * Math.random();
            this.circlingAngle = Math.random() * Math.PI * 2;
            this.circlingDirection = Math.random() > 0.5 ? 1 : -1;
            this.diveTarget = { x: 0, y: 0 };
        }
        getStat(stat) { return CONFIG.ENEMY.bat[stat]; }
        update(dt) {
            super.update(dt);
            if (this.stunTimer > 0) return;
            if(this.flashTimer > 0) this.flashTimer -= dt;
            if(this.diveCooldown > 0) this.diveCooldown -= dt;
            const dx = player.x - this.x, dy = player.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            switch (this.state) {
                case 'circling':
                    this.damage = 0;
                    this.circlingAngle += this.circlingDirection * (this.speed / this.getStat('circlingDist')) * dt;
                    const oscillation = Math.sin(gameTime * 3) * 30;
                    const targetX = player.x + Math.cos(this.circlingAngle) * (this.getStat('circlingDist') + oscillation);
                    const targetY = player.y + Math.sin(this.circlingAngle) * (this.getStat('circlingDist') + oscillation);
                    const moveDx = targetX - this.x, moveDy = targetY - this.y;
                    const moveDist = Math.sqrt(moveDx*moveDx + moveDy*moveDy);
                    if (moveDist > 1) {
                        this.x += (moveDx / moveDist) * this.speed * dt;
                        this.y += (moveDy / moveDist) * this.speed * dt;
                    }
                    const divingBats = enemies.filter(e => e instanceof Bat && (e.state === 'dive' || e.state === 'windup')).length;
                    if (dist < this.getStat('aggroRange') && this.diveCooldown <= 0 && divingBats < 2) {
                        this.state = 'windup'; this.stateTimer = this.getStat('diveWindup');
                        soundManager.play('uiClick');
                    }
                    break;
                case 'windup':
                    this.damage = 0; this.stateTimer -= dt;
                    const moveBackFactor = 50 * dt;
                    if (dist > 0) {
                        this.x -= (dx / dist) * moveBackFactor;
                        this.y -= (dy / dist) * moveBackFactor;
                    }
                    if (this.stateTimer <= 0) {
                        this.state = 'dive'; this.diveTarget.x = player.x; this.diveTarget.y = player.y;
                        this.damage = this.getStat('damage');
                    }
                    break;
                case 'dive':
                    const diveDx = this.diveTarget.x - this.x, diveDy = this.diveTarget.y - this.y;
                    const diveDist = Math.sqrt(diveDx*diveDx + diveDy*diveDy);
                    if (diveDist > this.size) {
                        this.x += (diveDx / diveDist) * this.getStat('diveSpeed') * dt;
                        this.y += (diveDy / diveDist) * this.getStat('diveSpeed') * dt;
                        createParticleBurst(this.x, this.y, 1, this.color, 0.3, 3, 20);
                    } else {
                        this.state = 'recover'; this.stateTimer = 1.0;
                    }
                    break;
                case 'recover':
                    this.damage = 0; this.stateTimer -= dt;
                    if (dist < this.getStat('circlingDist') && dist > 0) {
                         this.x -= (dx / dist) * this.speed * 0.8 * dt;
                         this.y -= (dy / dist) * this.speed * 0.8 * dt;
                    }
                    if (this.stateTimer <= 0) {
                        this.state = 'circling'; this.diveCooldown = this.getStat('diveCooldown');
                    }
                    break;
            }
        }
        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = playerData.graphics.effectsOpacity;
            if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
                if (this.state === 'windup' || this.isChampion) {
                    const glow = Math.abs(Math.sin(gameTime * 5));
                    ctx.shadowBlur = (this.isChampion ? 15 : 10) + glow * 10;
                    ctx.shadowColor = this.isChampion ? '#ffd700' : this.color;
                    ctx.globalAlpha *= 0.5 + glow * 0.5;
                }
            }
            ctx.translate(this.x, this.y);
            const flapAngle = Math.sin(gameTime * 30) * 0.5;
            const mainColor = this.flashTimer > 0 ? '#FFFFFF' : (this.stunTimer > 0 ? '#ffff99' : this.color);
            const wingColor = this.flashTimer > 0 ? '#DDDDDD' : '#c74283';
            const s = this.size;
            const bodyWidth = s, bodyHeight = s * 0.8, wingWidth = s * 1.5, wingHeight = s * 0.7;
            ctx.save();
            ctx.translate(bodyWidth / 2.5, 0); ctx.rotate(flapAngle);
            ctx.fillStyle = wingColor; ctx.fillRect(0, -wingHeight / 2, wingWidth, wingHeight);
            ctx.restore();
            ctx.save();
            ctx.translate(-bodyWidth / 2.5, 0); ctx.rotate(-flapAngle);
            ctx.fillStyle = wingColor; ctx.fillRect(-wingWidth, -wingHeight / 2, wingWidth, wingHeight);
            ctx.restore();
            ctx.fillStyle = mainColor;
            ctx.fillRect(-bodyWidth / 2, -bodyHeight / 2, bodyWidth, bodyHeight);
            const earSize = s * 0.3;
            ctx.fillRect(-bodyWidth / 2, -bodyHeight / 2 - earSize, earSize, earSize);
            ctx.fillRect(bodyWidth / 2 - earSize, -bodyHeight / 2 - earSize, earSize, earSize);
            ctx.restore();
        }
    }
    class Mage extends Enemy {
        constructor(x, y) {
            super(x, y, 'mage');
            this.attackCooldown = 3.5; this.healCooldown = 10; this.castingTime = 0.6; 
            this.attackTimer = 2.0 + Math.random() * this.attackCooldown;
            this.healTimer = 5.0 + Math.random() * this.healCooldown;
            this.preferredDistance = 400;
            this.castingState = 'none'; this.castingTimer = 0;
            this.runes = [
                { angle: 0, dist: this.size * 1.2 }, { angle: Math.PI * 2 / 3, dist: this.size * 1.2 }, { angle: Math.PI * 4 / 3, dist: this.size * 1.2 },
            ];
        }
        update(dt) {
            super.update(dt);
            if (this.stunTimer > 0) {
                 this.castingState = 'none';
                 return;
            }
            if (this.flashTimer > 0) this.flashTimer -= dt;
            if (this.castingState !== 'none') {
                this.castingTimer -= dt;
                this.runes.forEach(rune => {
                    if (this.castingState === 'attacking') rune.dist = this.size * 1.2 + Math.sin(this.castingTimer * Math.PI / this.castingTime) * 15;
                    else rune.dist = this.size * 1.2 - Math.sin(this.castingTimer * Math.PI / this.castingTime) * 5;
                });
                if (this.castingTimer <= 0) {
                    if (this.castingState === 'attacking') this.attack();
                    if (this.castingState === 'healing') this.performHeal();
                    this.castingState = 'none';
                }
                return;
            }
            this.runes.forEach(rune => { rune.angle += 2 * dt; });
            const dx = player.x - this.x, dy = player.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            let moveDirectionX = 0, moveDirectionY = 0;
            if (dist > 0) {
                if (dist < this.preferredDistance - 50) { moveDirectionX = -dx / dist; moveDirectionY = -dy / dist; }
                else if (dist > this.preferredDistance + 50) { moveDirectionX = dx / dist; moveDirectionY = dy / dist; }
            }
            this.x += moveDirectionX * this.speed * dt;
            this.y += moveDirectionY * this.speed * dt;
            this.attackTimer -= dt; this.healTimer -= dt;
            if (this.attackTimer <= 0) {
                this.castingState = 'attacking'; this.castingTimer = this.castingTime; this.attackTimer = this.attackCooldown;
            } else if (this.healTimer <= 0) {
                this.castingState = 'healing'; this.castingTimer = this.castingTime; this.healTimer = this.healCooldown;
            }
        }
        attack() { enemyProjectiles.push(new EnergyBall(this.x, this.y, player, 300, 12)); }
        performHeal() {
            const healRadius = 250;
            const healAmountPercent = 0.10;
            let healedSomeone = false;
            enemies.forEach(ally => {
                if (ally !== this && (ally.x - this.x)**2 + (ally.y - this.y)**2 < healRadius**2) {
                    if (ally.hp < ally.maxHp) {
                        ally.heal(ally.maxHp * healAmountPercent);
                        createParticleLine(this.x, this.y, ally.x, ally.y, 'rgba(77, 255, 158, 0.7)');
                        healedSomeone = true;
                    }
                }
            });
            if (healedSomeone) createParticleBurst(this.x, this.y, 20, 'rgba(77, 255, 158, 0.7)', 0.6, 4, 100);
        }
        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = playerData.graphics.effectsOpacity;
            ctx.translate(this.x, this.y);
            const s = this.size;
            const robeColor = this.flashTimer > 0 ? '#DDDDDD' : (this.stunTimer > 0 ? '#ffff99' : this.color);
            const bob = Math.sin(gameTime * 4) * 2;
            ctx.fillStyle = robeColor;
            if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = this.color; ctx.shadowBlur = 12;
            }
            ctx.beginPath();
            ctx.moveTo(0, -s / 2 + bob);
            ctx.bezierCurveTo(s, -s / 2 + bob, s, s/2 + bob, 0, s + bob);
            ctx.bezierCurveTo(-s, s/2 + bob, -s, -s / 2 + bob, 0, -s / 2 + bob);
            ctx.fill();
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.beginPath(); ctx.arc(0, -s*0.1 + bob, s * 0.4, 0, Math.PI * 2); ctx.fill();
            this.runes.forEach(rune => {
                const runeX = Math.cos(rune.angle) * rune.dist, runeY = Math.sin(rune.angle) * rune.dist;
                const runeSize = s * 0.15;
                ctx.fillStyle = this.isChampion ? '#ffd700' : robeColor;
                ctx.fillRect(runeX - runeSize, runeY - runeSize + bob, runeSize*2, runeSize*2);
            });
            if (this.castingState !== 'none' || this.isChampion) {
                const castingProgress = this.castingState !== 'none' ? 1 - (this.castingTimer / this.castingTime) : 1;
                const glow = Math.sin(castingProgress * Math.PI);
                if (currentGraphics && currentGraphics.shadows) {
                    if (this.isChampion) {
                        ctx.shadowColor = '#ffd700';
                        ctx.shadowBlur = 15 + Math.abs(Math.sin(gameTime * 5)) * 10;
                    }
                    if (this.castingState === 'attacking') {
                        ctx.fillStyle = 'rgba(255, 150, 255, 0.7)'; ctx.shadowColor = '#FFFFFF'; ctx.shadowBlur = 15 + glow * 20;
                        this.runes.forEach(rune => {
                            const runeX = Math.cos(rune.angle) * rune.dist, runeY = Math.sin(rune.angle) * rune.dist;
                            ctx.beginPath(); ctx.arc(runeX, runeY + bob, s * 0.2, 0, Math.PI * 2); ctx.fill();
                        });
                    } else if (this.castingState === 'healing') {
                        ctx.fillStyle = 'rgba(150, 255, 150, 0.7)'; ctx.shadowColor = '#adff2f'; ctx.shadowBlur = 15 + glow * 20;
                        ctx.beginPath(); ctx.arc(0, bob, s * 0.8, 0, Math.PI * 2); ctx.fill();
                    }
                }
            }
            ctx.restore();
        }
    }
    class Brute extends Enemy {
        constructor(x, y) {
            super(x, y, 'brute');
            this.state = 'chasing'; this.stateTimer = 0; this.chargeTarget = { x: 0, y: 0 };
            this.aggroRange = 300; this.windupDuration = 0.5; this.chargeSpeed = 900;
            this.chargeDuration = 0.30; this.slamRadius = 100;
            this.slamDamage = CONFIG.ENEMY.brute.slamDamage;
            this.slamKnockback = 30; this.recoverCooldown = 1.0;
        }
        update(dt) {
            super.update(dt);
            if (this.stunTimer > 0) return;
            if (this.flashTimer > 0) this.flashTimer -= dt;
            const dx = player.x - this.x, dy = player.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            switch (this.state) {
                case 'chasing':
                    this.damage = CONFIG.ENEMY.brute.damage;
                    if (dist > this.size / 2) {
                        this.x += (dx / dist) * this.speed * dt; this.y += (dy / dist) * this.speed * dt;
                    }
                    if (dist < this.aggroRange) {
                        this.state = 'windup'; this.stateTimer = this.windupDuration; this.chargeTarget = { x: player.x, y: player.y };
                        soundManager.play('uiClick');
                    }
                    break;
                case 'windup':
                    this.damage = 0; this.stateTimer -= dt;
                    if (dist > 0) {
                        const moveBackFactor = 30 * dt;
                        this.x -= (dx / dist) * moveBackFactor; this.y -= (dy / dist) * moveBackFactor;
                    }
                    if (this.stateTimer <= 0) {
                        this.state = 'charging'; this.stateTimer = this.chargeDuration;
                    }
                    break;
                case 'charging':
                    this.damage = CONFIG.ENEMY.brute.damage; this.stateTimer -= dt;
                    const chargeDx = this.chargeTarget.x - this.x, chargeDy = this.chargeTarget.y - this.y;
                    const chargeDist = Math.sqrt(chargeDx * chargeDx + chargeDy * chargeDy);
                    if (chargeDist > 1) {
                        this.x += (chargeDx / chargeDist) * this.chargeSpeed * dt;
                        this.y += (chargeDy / chargeDist) * this.chargeSpeed * dt;
                    }
                    createParticleBurst(this.x, this.y, 1, 'rgba(255, 77, 77, 0.5)', 0.4, 3, 30);
                    if (this.stateTimer <= 0 || chargeDist <= this.size) {
                        this.performSlam(); this.state = 'recovering'; this.stateTimer = this.recoverCooldown;
                    }
                    break;
                case 'recovering':
                    this.damage = 0; this.stateTimer -= dt;
                    if (this.stateTimer <= 0) this.state = 'chasing';
                    break;
            }
        }
        performSlam() {
            camera.startShake(10, 0.25);
            soundManager.play('hit');
            createParticleBurst(this.x, this.y, 30, this.color, 0.8, 5, 200);
            const dx = player.x - this.x, dy = player.y - this.y;
            const distSq = dx * dx + dy * dy;
            if (distSq < this.slamRadius * this.slamRadius) {
                player.takeDamage(this.slamDamage);
                if (distSq > 0) {
                    const dist = Math.sqrt(distSq);
                    player.x += (dx / dist) * this.slamKnockback;
                    player.y += (dy / dist) * this.slamKnockback;
                }
                if (typeof player.applyStun === 'function') player.applyStun(this.stunDuration);
            }
        }
        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = playerData.graphics.effectsOpacity;
            ctx.translate(this.x, this.y);
            const s = this.size;
            let bodyColor = this.flashTimer > 0 ? '#ffffff' : (this.stunTimer > 0 ? '#ffff99' : this.color);
            let fistColor = this.flashTimer > 0 ? '#dddddd' : '#cc3d3d';
            let fistSize = s * 0.4, bodyWidth = s;
            if (currentGraphics && currentGraphics.shadows) {
                if (this.state === 'windup' || this.isChampion) {
                    const glow = Math.abs(Math.sin((this.windupDuration - this.stateTimer) * Math.PI / this.windupDuration * 5));
                    ctx.shadowColor = this.isChampion ? '#ffd700' : '#ff8888';
                    ctx.shadowBlur = (this.isChampion ? 15 : 10) + glow * (this.isChampion ? 10 : 20);
                    fistSize += glow * 5;
                }
            }
            if (this.state === 'charging') bodyWidth = s * 1.2;
            else if (this.state === 'recovering') ctx.globalAlpha *= 0.7;
            ctx.fillStyle = fistColor;
            ctx.fillRect(-bodyWidth / 2 - fistSize * 0.8, -s / 2, fistSize, s);
            ctx.fillRect(bodyWidth / 2 - fistSize * 0.2, -s / 2, fistSize, s);
            ctx.fillStyle = bodyColor;
            if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
            }
            ctx.fillRect(-bodyWidth / 2, -s / 2, bodyWidth, s);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            const eyeSize = s * 0.1;
            ctx.fillRect(-s * 0.2 - eyeSize / 2, -s * 0.15 - eyeSize/2, eyeSize, eyeSize);
            ctx.fillRect(s * 0.2 - eyeSize / 2, -s * 0.15 - eyeSize/2, eyeSize, eyeSize);
            ctx.restore();
        }
    }
class SpectralElder extends Enemy {
        constructor(x, y) {
            super(x, y, 'spectral_elder');
            this.maxHp = CONFIG.ENEMY.spectral_elder.hp; this.hp = this.maxHp; this.size = CONFIG.ENEMY.spectral_elder.size; this.speed = 80; this.damage = 0; 
            this.xpValue = CONFIG.ENEMY.spectral_elder.xp; this.phase = 1; this.isBoss = true; this.castingInfo = null; 
            this.orbitingSkulls = [
                { angle: 0, dist: this.size * 1.5, size: 15 }, { angle: Math.PI, dist: this.size * 1.5, size: 15 },
                { angle: Math.PI / 2, dist: this.size * 2.0, size: 12 }, { angle: 3 * Math.PI / 2, dist: this.size * 2.0, size: 12 },
            ];
            this.trail = []; this.trailTimer = 0.05; this.actionTimer = 2;
            this.teleportCooldown = 7; this.summonCooldown = 10; this.soulBurstCooldown = 3; this.soulHarvestCooldown = 12;
        }
        update(dt) {
            super.update(dt);
            if (this.stunTimer > 0) return;
            this.trailTimer -= dt;
            if (this.trailTimer <= 0) {
                this.trail.push({ x: this.x, y: this.y, size: this.size, alpha: 0.5 });
                this.trailTimer = 0.05;
            }
            for (let i = this.trail.length - 1; i >= 0; i--) {
                this.trail[i].alpha -= dt * 2;
                if (this.trail[i].alpha <= 0) { this.trail.splice(i, 1); }
            }
            if (this.castingInfo) {
                this.castingInfo.progress += dt;
                const coreColor = this.phase === 1 ? 'rgba(220, 240, 255, 0.9)' : 'rgba(255, 180, 180, 0.9)';
                if (Math.random() < 0.6) {
                    const finalCount = Math.ceil(1 * (currentGraphics ? currentGraphics.particleMultiplier : 1));
                    for (let i = 0; i < finalCount; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = 300 * (1 - (this.castingInfo.progress / this.castingInfo.duration));
                        particles.push(new Particle(this.x + Math.cos(angle) * dist, this.y + Math.sin(angle) * dist, coreColor, 0.3, 3, -400));
                    }
                }
                if (this.castingInfo.progress >= this.castingInfo.duration) {
                    this.finishAction(this.castingInfo.type);
                    this.castingInfo = null;
                }
                return; 
            }
            if (this.phase === 1 && this.hp / this.maxHp <= 0.5) { this.enterPhase2(); }
            this.actionTimer -= dt; this.teleportCooldown -= dt; this.summonCooldown -= dt;
            this.soulBurstCooldown -= dt;
            if (this.phase === 2) this.soulHarvestCooldown -= dt;
            this.orbitingSkulls.forEach((skull, i) => { skull.angle += (1 + i * 0.1) * dt; });
            const dx = player.x - this.x, dy = player.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > 300) { 
                this.x += (dx / dist) * this.speed * dt; this.y += (dy / dist) * this.speed * dt;
            } else {
                 this.x -= (dx / dist) * this.speed * 0.5 * dt;
                 this.y -= (dy / dist) * this.speed * 0.5 * dt;
            }
            if (this.actionTimer <= 0) { this.performAction(); }
            if (this.flashTimer > 0) this.flashTimer -= dt;
        }
        performAction() {
            const actions = [];
            if (this.teleportCooldown <= 0) actions.push('teleport');
            if (this.summonCooldown <= 0) actions.push('summon');
            if (this.soulBurstCooldown <= 0) actions.push('soulBurst');
            if (this.phase === 2 && this.soulHarvestCooldown <= 0) actions.push('soulHarvest');
            if (actions.length === 0) { actions.push('soulBurst'); }
            const chosenAction = actions[Math.floor(Math.random() * actions.length)];
            this.startAction(chosenAction);
        }
        startAction(type) {
             switch (type) {
                case 'teleport': this.finishAction('teleport'); break;
                case 'summon':
                    this.castingInfo = { type: 'summon', duration: 1.5, progress: 0 };
                    this.actionTimer = 2;
                    break;
                case 'soulHarvest':
                    this.castingInfo = { type: 'soulHarvest', duration: 2.5, progress: 0 };
                    this.actionTimer = this.castingInfo.duration;
                    break;
                case 'soulBurst': default:
                    this.castingInfo = { type: 'soulBurst', duration: 1.0, progress: 0 };
                    this.actionTimer = 1.5;
                    break;
            }
        }
        finishAction(type) {
             switch (type) {
                case 'teleport':
                    this.ghostTeleport();
                    this.teleportCooldown = this.phase === 1 ? 8 : 5;
                    this.actionTimer = this.phase === 2 ? 0.2 : 1.0;
                    break;
                case 'summon':
                    this.summonEchoes();
                    this.summonCooldown = this.phase === 1 ? 12 : 8;
                    this.actionTimer = 2;
                    break;
                case 'soulHarvest':
                    this.soulHarvest();
                    this.soulHarvestCooldown = 15;
                    this.actionTimer = 2.0;
                    break;
                case 'soulBurst': default:
                    this.soulBurst();
                    this.soulBurstCooldown = this.phase === 1 ? 3 : 1.5;
                    this.actionTimer = this.soulBurstCooldown;
                    break;
            }
        }
        soulBurst() {
            const amount = this.phase === 1 ? 6 : 10;
            for (let i = 0; i < amount; i++) {
                setTimeout(() => {
                    if (!this.isAlive) return;
                    enemyProjectiles.push(new HomingSoul(this.x, this.y, player, 180, 10, 'enemy'));
                }, i * 150);
            }
        }
        summonEchoes() {
            const amount = this.phase === 1 ? 4 : 6;
            for (let i = 0; i < amount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const spawnX = this.x + Math.cos(angle) * 100;
                const spawnY = this.y + Math.sin(angle) * 100;
                enemies.push(new MageEcho(spawnX, spawnY));
            }
        }
        ghostTeleport() {
            createParticleBurst(this.x, this.y, 50, 'rgba(150, 200, 255, 0.5)', 1, 5, 200);
            const angle = Math.random() * Math.PI * 2;
            const dist = 400 + Math.random() * 200;
            this.x = player.x + Math.cos(angle) * dist;
            this.y = player.y + Math.sin(angle) * dist;
            this.x = Math.max(this.size, Math.min(this.x, CONFIG.MAP_SIZE.width - this.size));
            this.y = Math.max(this.size, Math.min(this.y, CONFIG.MAP_SIZE.height - this.size));
            createParticleBurst(this.x, this.y, 50, 'rgba(150, 200, 255, 0.5)', 1, 5, 200);
        }
        soulHarvest() {
            const warningCircle = new WarningCircle(player.x, player.y, 400, 2.5, (circleX, circleY) => {
                if (!this.isAlive) return;
                const dx = player.x - circleX;
                const dy = player.y - circleY;
                if (dx * dx + dy * dy < 400 * 400) {
                    player.takeDamage(80); 
                    player.applyStun(2); 
                }
                createParticleBurst(circleX, circleY, 200, 'rgba(255, 50, 100, 0.7)', 1.5, 8, 400);
                camera.startShake(20, 0.8);
            });
            effects.push(warningCircle);
        }
        enterPhase2() {
            this.phase = 2;
            floatingTexts.push(new FloatingText(this.x, this.y, 'ENFURECIDO!', '#ff4d4d', 3, 24));
            this.speed *= 1.3;
            this.teleportCooldown = 5;
            this.summonCooldown = 8;
            this.soulBurstCooldown = 1.5;
            this.soulHarvestCooldown = 10;
        }
        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = playerData.graphics.effectsOpacity;
            const phaseColor = this.phase === 1 ? 'rgba(150, 200, 255, 0.8)' : 'rgba(255, 100, 100, 0.9)';
            const coreColor = this.phase === 1 ? 'rgba(220, 240, 255, 0.9)' : 'rgba(255, 180, 180, 0.9)';
            const bob = Math.sin(gameTime * 2) * 10;
            for (const trailPart of this.trail) {
                ctx.save();
                ctx.globalAlpha = trailPart.alpha * playerData.graphics.effectsOpacity;
                ctx.fillStyle = phaseColor;
                this.drawCloakedShape(ctx, trailPart.x, trailPart.y + bob, trailPart.size);
                ctx.restore();
            }
            const auraPulse = Math.sin(gameTime * (this.phase === 1 ? 3 : 7));
            const auraColor = this.phase === 1 ? 'rgba(150, 200, 255,' : 'rgba(255, 80, 80,';
            const auraSize = this.size + 10 + auraPulse * 8;
            ctx.save();
            ctx.globalAlpha = 0.5 * playerData.graphics.effectsOpacity;
            ctx.fillStyle = auraColor + '0.2)';
            if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = coreColor; ctx.shadowBlur = 20;
            }
            ctx.beginPath();
            ctx.arc(this.x, this.y + bob, auraSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            ctx.save();
            ctx.globalAlpha = playerData.graphics.effectsOpacity;
            ctx.fillStyle = this.flashTimer > 0 ? '#ffffff' : phaseColor;
            if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = coreColor; ctx.shadowBlur = 30;
            }
            this.drawCloakedShape(ctx, this.x, this.y + bob, this.size);
            ctx.restore();
            this.orbitingSkulls.forEach(skull => {
                const x = this.x + Math.cos(skull.angle) * skull.dist;
                const y = this.y + Math.sin(skull.angle) * skull.dist + bob;
                let skullGlow = 15;
                if (this.castingInfo) {
                    const chargeProgress = this.castingInfo.progress / this.castingInfo.duration;
                    skullGlow = 15 + Math.sin(chargeProgress * Math.PI) * 30;
                }
                ctx.save();
                ctx.globalAlpha = playerData.graphics.effectsOpacity;
                ctx.fillStyle = coreColor;
                if (currentGraphics && currentGraphics.shadows) {
                    ctx.shadowColor = this.phase === 2 && this.castingInfo ? 'red' : coreColor;
                    ctx.shadowBlur = skullGlow;
                }
                ctx.fillRect(x - skull.size / 2, y - skull.size / 2, skull.size, skull.size);
                ctx.fillStyle = 'black';
                ctx.fillRect(x - skull.size / 4, y - skull.size / 4, skull.size / 5, skull.size / 5); 
                ctx.fillRect(x + skull.size / 8, y - skull.size / 4, skull.size / 5, skull.size / 5); 
                ctx.restore();
            });
            ctx.restore();
        }
        drawCloakedShape(ctx, x, y, size) {
            const s = size;
            ctx.beginPath();
            ctx.moveTo(x, y - s); 
            ctx.quadraticCurveTo(x + s, y - s * 0.2, x + s * 0.7, y + s * 0.5); 
            ctx.quadraticCurveTo(x, y + s * 1.2, x - s * 0.7, y + s * 0.5); 
            ctx.quadraticCurveTo(x - s, y - s * 0.2, x, y - s); 
            ctx.fill();
        }
        die() {
            gameState = 'paused';
            this.isAlive = false;
            runStats.enemiesDefeated++;
            playerData.persistentStats['spectral_elder_defeated'] = (playerData.persistentStats['spectral_elder_defeated'] || 0) + 1;
            playerData.spectralElderDefeated = true;
            createParticleBurst(this.x, this.y, 300, 'rgba(150, 200, 255, 1)', 3, 10, 500);
            camera.startShake(30, 2);
            for (let i = 0; i < 20; i++) {
                expOrbs.push(new ExpOrb(this.x + (Math.random() - 0.5) * 100, this.y + (Math.random() - 0.5) * 100, 50));
            }
            for (let i = 0; i < 50; i++) {
                soulGems.push(new SoulGem(this.x + (Math.random() - 0.5) * 100, this.y + (Math.random() - 0.5) * 100));
            }
            bossWaveActive = false;
            floatingTexts.push(new FloatingText(player.x, player.y - 100, 'VIT√ìRIA!', '#ffd700', 5, 32));
            setTimeout(() => {
                DOM.bossHud.style.display = 'none';
                floatingTexts.push(new FloatingText(player.x, player.y - 120, 'A pr√≥xima onda se aproxima...', '#ffffff', 8, 22));
                setTimeout(() => {
                    gameState = 'playing';
                    wave++;
                    waveTimer = 30;
                    spawnWave();
                }, 8000); 
            }, 5000); 
        }
    }
    // --- NOVOS INIMIGOS E CHEFE FINAL ---
    class Wraith extends Enemy {
        constructor(x, y) {
            super(x, y, 'wraith');
            this.state = 'chasing';
            this.stateTimer = 0;
            this.phaseCooldown = 2;
            this.phaseSpeed = 500;
            this.phaseDuration = 0.8;
            this.alpha = 1;
        }

        update(dt) {
            super.update(dt);
            if (this.stunTimer > 0) return;
            if (this.flashTimer > 0) this.flashTimer -= dt;

            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            switch (this.state) {
                case 'chasing':
                    this.alpha = 1;
                    this.damage = CONFIG.ENEMY.wraith.damage;
                    this.stateTimer -= dt;
                    if (dist > 1) {
                        this.x += (dx / dist) * this.speed * dt;
                        this.y += (dy / dist) * this.speed * dt;
                    }
                    if (this.stateTimer <= 0) {
                        this.state = 'phasing';
                        this.stateTimer = this.phaseDuration;
                    }
                    break;
                case 'phasing':
                    this.alpha = 0.4;
                    this.damage = 0; // No damage while phasing through
                    this.stateTimer -= dt;
                    if (dist > 1) {
                        this.x += (dx / dist) * this.phaseSpeed * dt;
                        this.y += (dy / dist) * this.phaseSpeed * dt;
                        createParticleBurst(this.x, this.y, 1, 'rgba(162, 162, 208, 0.5)', 0.3, 2, 20);
                    }
                    if (this.stateTimer <= 0) {
                        this.state = 'cooldown';
                        this.stateTimer = this.phaseCooldown;
                    }
                    break;
                case 'cooldown':
                    this.alpha = 1;
                    this.damage = CONFIG.ENEMY.wraith.damage;
                    this.stateTimer -= dt;
                     if (dist > 150) { // Keep some distance
                        this.x += (dx / dist) * this.speed * 0.5 * dt;
                        this.y += (dy / dist) * this.speed * 0.5 * dt;
                    }
                    if (this.stateTimer <= 0) {
                        this.state = 'chasing';
                        this.stateTimer = 1.5; // Chase for a bit before phasing again
                    }
                    break;
            }
        }
        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = this.alpha * playerData.graphics.effectsOpacity;
            const mainColor = this.flashTimer > 0 ? '#FFFFFF' : (this.stunTimer > 0 ? '#ffff99' : this.color);
            const bob = Math.sin(gameTime * 5) * 3;
            if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 15;
            }
            ctx.fillStyle = mainColor;
            ctx.beginPath();
            ctx.moveTo(this.x, this.y - this.size + bob);
            ctx.bezierCurveTo(this.x + this.size, this.y, this.x, this.y + this.size + bob, this.x - this.size, this.y);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.beginPath();
            ctx.arc(this.x, this.y - this.size * 0.2 + bob, this.size * 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
    }
    class CrystalGolem extends Enemy {
        constructor(x, y) {
            super(x, y, 'crystal_golem');
            this.slamCooldown = 4.0;
            this.slamTimer = this.slamCooldown;
            this.slamRadius = 120;
            this.isWindingUp = false;
            this.windupTimer = 0;
            this.windupDuration = 1.2;
        }
        update(dt) {
            super.update(dt);
            if (this.stunTimer > 0) { this.isWindingUp = false; return; }
            if (this.flashTimer > 0) this.flashTimer -= dt;

            if (this.isWindingUp) {
                this.windupTimer -= dt;
                if (this.windupTimer <= 0) {
                    this.performSlam();
                    this.isWindingUp = false;
                }
                return;
            }

            this.slamTimer -= dt;
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist > this.size) {
                this.x += (dx / dist) * this.speed * dt;
                this.y += (dy / dist) * this.speed * dt;
            }

            if (this.slamTimer <= 0 && dist < this.slamRadius * 1.5) {
                this.isWindingUp = true;
                this.windupTimer = this.windupDuration;
                this.slamTimer = this.slamCooldown;
            }
        }
        performSlam() {
            camera.startShake(12, 0.3);
            soundManager.play('hit');
            effects.push(new Shockwave(this.x, this.y, this.slamRadius, this.damage * 1.5));
        }
        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = playerData.graphics.effectsOpacity;
            ctx.translate(this.x, this.y);

            const mainColor = this.flashTimer > 0 ? '#FFFFFF' : (this.stunTimer > 0 ? '#ffff99' : this.color);
            const s = this.size;
            let armHeight = 0;

            if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 15;
            }

            if (this.isWindingUp) {
                const windupProgress = 1 - (this.windupTimer / this.windupDuration);
                armHeight = Math.sin(windupProgress * Math.PI) * (-s * 0.5);
                const glow = Math.sin(windupProgress * Math.PI) * 20;
                if (currentGraphics && currentGraphics.shadows) {
                    ctx.shadowBlur += glow;
                    ctx.shadowColor = '#FFFFFF';
                }
            }

            // Body
            ctx.fillStyle = mainColor;
            ctx.fillRect(-s / 2, -s / 2, s, s);
            // Arms
            ctx.fillStyle = '#65c2f0';
            ctx.fillRect(-s * 0.8, -s * 0.4 + armHeight, s * 0.3, s * 0.8);
            ctx.fillRect(s * 0.5, -s * 0.4 + armHeight, s * 0.3, s * 0.8);
            // Head
            ctx.fillStyle = '#a8e0ff';
            ctx.fillRect(-s * 0.2, -s * 0.8, s * 0.4, s * 0.3);

            ctx.restore();
        }
    }
    class AbyssWorm extends Enemy {
        constructor(x, y) {
            super(x, y, 'abyss_worm');
            this.state = 'burrowed';
            this.stateTimer = 2.0; // Time to stay burrowed
            this.isVulnerable = false;
        }
        update(dt) {
            super.update(dt);
            if (this.stunTimer > 0 && this.isVulnerable) return;
            if (this.flashTimer > 0) this.flashTimer -= dt;

            this.stateTimer -= dt;

            switch (this.state) {
                case 'burrowed':
                    this.isVulnerable = false;
                    this.damage = 0;
                    const dx = player.x - this.x;
                    const dy = player.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 1) {
                        this.x += (dx / dist) * this.speed * 1.5 * dt; // Faster while burrowed
                        this.y += (dy / dist) * this.speed * 1.5 * dt;
                    }
                    createParticleBurst(this.x, this.y, 1, 'rgba(100, 50, 150, 0.4)', 0.5, 3, 20);
                    if (this.stateTimer <= 0) {
                        this.state = 'emerging';
                        this.stateTimer = 0.5; // Warning time
                        effects.push(new WarningCircle(this.x, this.y, this.size * 2, 0.5, () => {}));
                    }
                    break;
                case 'emerging':
                    if (this.stateTimer <= 0) {
                        this.state = 'attacking';
                        this.isVulnerable = true;
                        this.damage = CONFIG.ENEMY.abyss_worm.damage;
                        this.stateTimer = 2.5; // Time to stay above ground
                    }
                    break;
                case 'attacking':
                    const adx = player.x - this.x;
                    const ady = player.y - this.y;
                    const adist = Math.sqrt(adx * adx + ady * ady);
                     if (adist > this.size) {
                        this.x += (adx / adist) * this.speed * 0.5 * dt;
                        this.y += (ady / adist) * this.speed * 0.5 * dt;
                    }
                    if (this.stateTimer <= 0) {
                        this.state = 'burrowed';
                        this.stateTimer = 3.0;
                    }
                    break;
            }
        }
        takeDamage(amount) {
            if (this.isVulnerable) {
                super.takeDamage(amount);
            }
        }
        draw(ctx) {
            if (this.state === 'burrowed') return;

            ctx.save();
            ctx.globalAlpha = playerData.graphics.effectsOpacity;
            const mainColor = this.flashTimer > 0 ? '#FFFFFF' : (this.stunTimer > 0 ? '#ffff99' : this.color);
            if (this.state === 'emerging') {
                const emergeProgress = 1 - (this.stateTimer / 0.5);
                ctx.globalAlpha *= emergeProgress;
            }
             if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
            }
            ctx.fillStyle = mainColor;
            ctx.beginPath();
            ctx.ellipse(this.x, this.y, this.size, this.size / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#4b0082';
            ctx.beginPath();
            ctx.ellipse(this.x, this.y, this.size*0.7, this.size/3, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
    }
    class ArcaneSentry extends Enemy {
        constructor(x, y) {
            super(x, y, 'arcane_sentry');
            this.attackCooldown = 2.5;
            this.attackTimer = this.attackCooldown;
            this.isFiring = false;
        }
        update(dt) {
            super.update(dt);
            if (this.flashTimer > 0) this.flashTimer -= dt;
            this.attackTimer -= dt;

            if (this.attackTimer <= 0) {
                this.attack();
                this.attackTimer = this.attackCooldown;
            }
        }
        attack() {
            this.isFiring = true;
            setTimeout(() => this.isFiring = false, 300);
            for(let i=0; i < 3; i++) {
                setTimeout(() => {
                     if (!this.isAlive) return;
                     enemyProjectiles.push(new EnergyBall(this.x, this.y, player, 350, this.damage));
                }, i * 100);
            }
        }
        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = playerData.graphics.effectsOpacity;
            ctx.translate(this.x, this.y);

            const mainColor = this.flashTimer > 0 ? '#FFFFFF' : (this.stunTimer > 0 ? '#ffff99' : this.color);
            const bob = Math.sin(gameTime * 3) * 4;
            const s = this.size;
            let glow = 15;

            if (this.isFiring) {
                glow = 30;
            }
            if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = this.color;
                ctx.shadowBlur = glow;
            }

            ctx.fillStyle = mainColor;
            ctx.beginPath();
            ctx.moveTo(0, -s / 2 + bob);
            ctx.lineTo(s / 2, s / 2 + bob);
            ctx.lineTo(-s / 2, s / 2 + bob);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#f0e68c';
             if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = '#FFFFFF';
                ctx.shadowBlur = this.isFiring ? 20 : 5;
            }
            ctx.beginPath();
            ctx.arc(0, bob, s*0.3, 0, Math.PI*2);
            ctx.fill();

            ctx.restore();
        }
    }
    class MagmaColossus extends Enemy {
        constructor(x, y) {
            super(x, y, 'magma_colossus');
            this.maxHp = CONFIG.ENEMY.magma_colossus.hp; this.hp = this.maxHp; this.size = CONFIG.ENEMY.magma_colossus.size;
            this.speed = 40; this.damage = 50; this.xpValue = CONFIG.ENEMY.magma_colossus.xp;
            this.isBoss = true; this.phase = 1;

            this.magmaBallCooldown = 4;
            this.lavaPoolCooldown = 8;
            this.summonCooldown = 12;
            this.eruptionCooldown = 15;
            this.actionTimer = 3;
        }
        update(dt) {
            super.update(dt);
            if (this.stunTimer > 0) return;
            if (this.flashTimer > 0) this.flashTimer -= dt;

            if (this.phase === 1 && this.hp <= this.maxHp / 2) {
                this.enterPhase2();
            }

            this.actionTimer -= dt;
            if (this.actionTimer <= 0) {
                this.performAction();
            }

            const dx = player.x - this.x, dy = player.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > this.size) {
                this.x += (dx / dist) * this.speed * dt;
                this.y += (dy / dist) * this.speed * dt;
            }
        }
        performAction() {
            const actions = ['magmaBall', 'lavaPool'];
            if (this.phase === 2) {
                actions.push('summon', 'eruption');
            }
            const action = actions[Math.floor(Math.random() * actions.length)];

            switch(action) {
                case 'magmaBall':
                    this.actionTimer = this.magmaBallCooldown;
                    enemyProjectiles.push(new MagmaBall(this.x, this.y, player, 180, this.damage));
                    break;
                case 'lavaPool':
                    this.actionTimer = this.lavaPoolCooldown;
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 100 + Math.random() * 200;
                    const targetX = player.x + Math.cos(angle) * dist;
                    const targetY = player.y + Math.sin(angle) * dist;
                    effects.push(new WarningCircle(targetX, targetY, 80, 1.5, (tx, ty) => {
                        effects.push(new LavaPool(tx, ty, 80, 10, 8));
                    }));
                    break;
                case 'summon':
                    this.actionTimer = this.summonCooldown;
                     for (let i = 0; i < 4; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        enemies.push(new LavaSpawn(this.x + Math.cos(angle) * 100, this.y + Math.sin(angle) * 100));
                    }
                    break;
                case 'eruption':
                    this.actionTimer = this.eruptionCooldown;
                    effects.push(new WarningCircle(this.x, this.y, 400, 3, (tx, ty) => {
                         if ((player.x - tx)**2 + (player.y - ty)**2 < 400**2) {
                             player.takeDamage(100);
                         }
                         camera.startShake(25, 1);
                    }));
                    break;
            }
        }
        enterPhase2() {
            this.phase = 2;
            this.speed *= 1.5;
            this.magmaBallCooldown = 3;
            this.lavaPoolCooldown = 6;
            floatingTexts.push(new FloatingText(this.x, this.y, 'N√öCLEO EXPOSTO!', '#ff4500', 3, 24));
        }
        draw(ctx) {
            ctx.save();
            const s = this.size;
            const color = this.flashTimer > 0 ? '#FFFFFF' : '#4a2a2a';
            const lavaColor = this.phase === 1 ? '#ff8c00' : '#ff4500';
            const pulse = Math.sin(gameTime * 5) * 5;

            if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = lavaColor;
                ctx.shadowBlur = 30 + pulse;
            }

            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, s, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = lavaColor;
            ctx.beginPath();
            ctx.arc(this.x, this.y, s * 0.8 + pulse, 0, Math.PI * 2);
            ctx.fill();

            if(this.phase === 2) {
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(this.x, this.y, s * 0.4 + pulse, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }
        die() {
            this.isAlive = false;
            gameOver(true); 
            floatingTexts.push(new FloatingText(this.x, this.y, 'VIT√ìRIA!', '#ffd700', 5, 40));
        }
    }
    class LavaSpawn extends Enemy {
        constructor(x, y) {
            super(x, y, 'lava_spawn');
            this.color = '#ff4500';
        }
        update(dt) {
            super.update(dt);
            if (this.stunTimer > 0) return;
            if (this.flashTimer > 0) this.flashTimer -= dt;
            const dx = player.x - this.x, dy = player.y - this.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist > this.size) {
                this.x += (dx/dist) * this.speed * dt;
                this.y += (dy/dist) * this.speed * dt;
            }
        }
        draw(ctx) {
            ctx.save();
            ctx.fillStyle = this.flashTimer > 0 ? '#FFFFFF' : this.color;
            if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
            }
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
    }
    class SlimeEcho extends Slime {
        constructor(x, y) {
            super(x, y);
            this.hp = 5; this.maxHp = 5; this.damage = 5; this.xpValue = 0; 
        }
        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = 0.6 * playerData.graphics.effectsOpacity;
            super.draw(ctx);
            ctx.restore();
        }
        die() {
            this.isAlive = false;
            runStats.enemiesDefeated++;
            createParticleBurst(this.x, this.y, 5, 'rgba(150, 200, 255, 0.5)');
        }
    }
    class MageEcho extends Mage {
        constructor(x, y) {
            super(x, y);
            this.hp = 15; this.maxHp = 15; this.damage = 8; this.xpValue = 0; 
        }
        performHeal() { /* Os ecos n√£o podem curar */ }
        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = 0.6 * playerData.graphics.effectsOpacity;
            super.draw(ctx);
            ctx.restore();
        }
        die() {
            this.isAlive = false;
            runStats.enemiesDefeated++;
            createParticleBurst(this.x, this.y, 5, 'rgba(190, 77, 255, 0.5)');
        }
    }
        // --- Sistema de Pets ---
   // --- Sistema de Pets ---
    class Pet {
        constructor(player, id) {
            this.player = player;
            this.id = id;
            this.x = player.x;
            this.y = player.y - 50;
            this.followDistance = 60; // Aumentado um pouco para melhor posicionamento
            this.speed = player.speed * 1.2; // Aumentado para melhor acompanhamento
            this.cooldownMultiplier = 1;
            this.damageMultiplier = 1;
        }
        update(dt) {
            // Movimento de acompanhamento suavizado (Lerp)
            const targetX = this.player.x + (this.player.lastMoveDirection.x * -10);
            const targetY = this.player.y - this.followDistance;
            const lerpFactor = 0.08;

            this.x += (targetX - this.x) * lerpFactor;
            this.y += (targetY - this.y) * lerpFactor;
        }
    }

    class WispPet extends Pet {
        constructor(player) {
            super(player, 'wisp');
            const stats = CONFIG.PETS.wisp;
            this.cooldown = stats.baseCooldown;
            this.damage = stats.baseDamage;
            this.timer = this.cooldown;
            this.blinkTimer = 0;
            this.blinkTarget = {x: this.x, y: this.y};
        }
        update(dt) {
            // Movimento de "piscar"
            this.blinkTimer -= dt;
            if (this.blinkTimer <= 0) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 20 + Math.random() * 20;
                this.blinkTarget.x = this.player.x + Math.cos(angle) * dist;
                this.blinkTarget.y = this.player.y - this.followDistance + Math.sin(angle) * dist;
                this.blinkTimer = 0.4 + Math.random() * 0.3;
                 createParticleBurst(this.x, this.y, 5, '#ff8c1a', 0.3, 3, 80);
            }
             // Movimento suavizado para o alvo do "piscar"
            this.x += (this.blinkTarget.x - this.x) * 0.1;
            this.y += (this.blinkTarget.y - this.y) * 0.1;


            this.timer -= dt;
            if (this.timer <= 0) {
                const target = findNearestEnemy(this, false, 450); // Alcance aumentado
                if (target) {
                    const finalDamage = this.damage * this.player.damageMultiplier * this.damageMultiplier;
                    const proj = new HomingSoul(this.x, this.y, target, 250, finalDamage, 'player');
                    proj.size = 10;
                    proj.isPet = true; 
                    // Marca o proj√©til como sendo do Wisp para desenho customizado
                    proj.isWispFire = true; 
                    enemyProjectiles.push(proj);
                    this.timer = this.cooldown * this.cooldownMultiplier;
                }
            }
        }
        draw(ctx) {
            ctx.save();
            ctx.globalAlpha *= playerData.graphics.effectsOpacity;

            const pulse = 1 + Math.sin(gameTime * 10) * 0.1;
            const color = '#ff8c1a';
            const eyeColor = '#ffff00';

            // Chama da cauda
            const tailAngle = Math.atan2(this.y - this.player.y, this.x - this.player.x);
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(tailAngle);
            const gradTail = ctx.createLinearGradient(0, 0, 40 * pulse, 0);
            gradTail.addColorStop(0, color);
            gradTail.addColorStop(1, 'transparent');
            ctx.fillStyle = gradTail;
            ctx.beginPath();
            ctx.moveTo(0,0);
            ctx.quadraticCurveTo(20 * pulse, -15 * pulse, 40 * pulse, 0);
            ctx.quadraticCurveTo(20 * pulse, 15 * pulse, 0, 0);
            ctx.fill();
            ctx.restore();


            // Cr√¢nio
            ctx.fillStyle = '#222';
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 2;
            if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = color; ctx.shadowBlur = 20 * pulse;
            }
            ctx.beginPath();
            ctx.arc(this.x, this.y, 10 * pulse, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Olhos brilhantes
            ctx.fillStyle = eyeColor;
             if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = eyeColor; ctx.shadowBlur = 15;
            }
            ctx.beginPath();
            ctx.arc(this.x - 4 * pulse, this.y - 2 * pulse, 2.5 * pulse, 0, Math.PI * 2);
            ctx.arc(this.x + 4 * pulse, this.y - 2 * pulse, 2.5 * pulse, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }
    }

    class GolemPet extends Pet {
         constructor(player) {
            super(player, 'golem');
            const stats = CONFIG.PETS.golem;
            this.cooldown = stats.baseCooldown;
            this.timer = this.cooldown * 0.5; // Starts earlier
            this.shieldActive = false;
            this.shieldHits = stats.baseShieldHits;
            this.shieldHitsLeft = 0;

            // Pedras flutuantes
            this.rocks = [
                { id: 'torso', size: 18, angle: 0, dist: 0, rotation: 0 },
                { id: 'fist1', size: 10, angle: Math.PI * 1.8, dist: 25, rotation: Math.random() * Math.PI },
                { id: 'fist2', size: 10, angle: Math.PI * 1.2, dist: 25, rotation: Math.random() * Math.PI },
            ];
        }
        update(dt) {
            super.update(dt);
            // Anima√ß√£o das pedras
            this.rocks.forEach(rock => {
                rock.angle += dt * 0.5;
                rock.rotation += dt * (rock.id === 'torso' ? 0.2 : 1.5);
            });


            this.timer -= dt;
            if (this.timer <= 0 && !this.shieldActive) {
                this.shieldActive = true;
                this.shieldHitsLeft = this.shieldHits;
                this.timer = this.cooldown * this.cooldownMultiplier;

                // Efeito visual da cria√ß√£o do escudo
                effects.push(new ShieldFormationEffect(
                    {x: this.x + Math.cos(this.rocks[1].angle) * this.rocks[1].dist, y: this.y + Math.sin(this.rocks[1].angle) * this.rocks[1].dist},
                    {x: this.x + Math.cos(this.rocks[2].angle) * this.rocks[2].dist, y: this.y + Math.sin(this.rocks[2].angle) * this.rocks[2].dist},
                    this.player
                ));

                floatingTexts.push(new FloatingText(player.x, player.y - 30, 'ESCUDO!', '#abfffa', 2, 12));
            }
        }
        draw(ctx) {
            ctx.save();
            ctx.globalAlpha *= playerData.graphics.effectsOpacity;

            // Desenha o escudo ativo
            if(this.shieldActive) {
                ctx.beginPath();
                const shieldAlpha = 0.4 + Math.sin(gameTime*15) * 0.3;
                ctx.strokeStyle = `rgba(171, 255, 250, ${shieldAlpha})`;
                ctx.fillStyle = `rgba(171, 255, 250, ${shieldAlpha * 0.2})`;
                ctx.lineWidth = 3;
                if (currentGraphics && currentGraphics.shadows) {
                   ctx.shadowColor = '#abfffa'; ctx.shadowBlur = 15;
                }
                ctx.arc(this.player.x, this.player.y, this.player.size + 8, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fill();
            }

            const runeColor = '#abfffa';
            // Desenha as rochas
            this.rocks.forEach(rock => {
                const rockX = this.x + Math.cos(rock.angle) * rock.dist;
                const rockY = this.y + Math.sin(rock.angle) * rock.dist;

                ctx.save();
                ctx.translate(rockX, rockY);
                ctx.rotate(rock.rotation);

                ctx.fillStyle = '#696969';
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 2;

                if (currentGraphics && currentGraphics.shadows) {
                    ctx.shadowColor = '#000'; ctx.shadowBlur = 10;
                }

                ctx.beginPath();
                ctx.rect(-rock.size/2, -rock.size/2, rock.size, rock.size);
                ctx.fill();
                ctx.stroke();

                // Desenha runas no torso
                if (rock.id === 'torso') {
                    const readyPulse = this.timer <= 0 ? (0.5 + Math.sin(gameTime * 10) * 0.5) : 0;
                    ctx.fillStyle = runeColor;
                    ctx.globalAlpha *= (this.timer / (this.cooldown * this.cooldownMultiplier)) * 0.5 + readyPulse;
                     if (currentGraphics && currentGraphics.shadows) {
                        ctx.shadowColor = runeColor; ctx.shadowBlur = 15;
                    }
                    ctx.font = `${rock.size * 0.8}px "Press Start 2P"`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('+', 0, 0);
                }

                ctx.restore();
            });

            ctx.restore();
        }
    }

    class SpritePet extends Pet {
        constructor(player) {
            super(player, 'sprite');
            const stats = CONFIG.PETS.sprite;
            this.cooldown = stats.baseCooldown;
            this.stunDuration = stats.baseStun;
            this.timer = this.cooldown;
            this.stunDurationMultiplier = 1;
        }
        update(dt) {
            // Vibra√ß√£o de movimento
            const targetX = this.player.x + 40;
            const targetY = this.player.y - this.followDistance;
            const lerpFactor = 0.05;
            this.x += (targetX - this.x) * lerpFactor + (Math.random() - 0.5) * 4;
            this.y += (targetY - this.y) * lerpFactor + (Math.random() - 0.5) * 4;


            this.timer -= dt;
            if (this.timer <= 0) {
                 const target = findNearestEnemy(this, false, 300); // Alcance aumentado
                 if(target) {
                    target.applyStun(this.stunDuration * this.stunDurationMultiplier);
                    // O raio j√° √© um efeito instant√¢neo que conecta o pet ao inimigo, como solicitado.
                    effects.push(new LightningBolt([{x:this.x, y:this.y}, {x:target.x, y:target.y}], false));
                    this.timer = this.cooldown * this.cooldownMultiplier;
                 }
            }
        }
        draw(ctx) {
            ctx.save();
            ctx.globalAlpha *= playerData.graphics.effectsOpacity;
            const pulse = 1 + Math.sin(gameTime * 30) * 0.4;
            const coreColor = '#ffffff';
            const arcColor1 = '#4f8be6';
            const arcColor2 = '#a463e8';

            // Arcos el√©tricos ca√≥ticos
             if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = arcColor1; ctx.shadowBlur = 20 * pulse;
            }
            ctx.lineWidth = 1.5 * pulse;
            for(let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                const angle = Math.random() * Math.PI * 2;
                const dist = (10 + Math.random() * 10) * pulse;
                ctx.strokeStyle = Math.random() > 0.5 ? arcColor1 : arcColor2;
                ctx.lineTo(this.x + Math.cos(angle) * dist, this.y + Math.sin(angle) * dist);
                ctx.stroke();
            }


            // N√∫cleo de energia pulsante
             if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = coreColor; ctx.shadowBlur = 15 * pulse;
            }
            const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, 8 * pulse);
            grad.addColorStop(0, coreColor);
            grad.addColorStop(0.7, 'rgba(200, 220, 255, 0.7)');
            grad.addColorStop(1, 'rgba(79, 139, 230, 0)');

            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(this.x, this.y, 8 * pulse, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
    }

    class SproutPet extends Pet {
        constructor(player) {
            super(player, 'sprout');
            const stats = CONFIG.PETS.sprout;
            this.cooldown = stats.baseCooldown;
            this.healAmount = stats.baseHeal;
            this.timer = this.cooldown;
            this.healMultiplier = 1;
            this.bobble = 0; // Para o gingado
        }
        update(dt) {
            // Movimento de gingado fofo
            this.bobble += dt * 8;
            const targetX = this.player.x - 40;
            const targetY = this.player.y - this.followDistance + Math.sin(this.bobble) * 3;
            const lerpFactor = 0.05;
            this.x += (targetX - this.x) * lerpFactor;
            this.y += (targetY - this.y) * lerpFactor;


            this.timer -= dt;
            if (this.timer <= 0) {
                const angle = Math.random() * Math.PI * 2;
                const spawnX = this.x + Math.cos(angle) * 10;
                const spawnY = this.y + Math.sin(angle) * 10;
                powerups.push(new HealingOrb(spawnX, spawnY, this.healAmount * this.healMultiplier));
                this.timer = this.cooldown * this.cooldownMultiplier;
            }
        }
        draw(ctx) {
            ctx.save();
            ctx.globalAlpha *= playerData.graphics.effectsOpacity;

            const bodyColor = '#228B22';
            const leafColor = '#3CB371';
            const flowerPetalColor = '#f0f0f0';
            const flowerCoreColor = '#90EE90';

            const bloomProgress = Math.max(0, 1 - (this.timer / (this.cooldown * this.cooldownMultiplier)));

            if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = '#000'; ctx.shadowBlur = 8;
            }

            ctx.translate(this.x, this.y);

            // "P√©s" de raiz
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(-5, 5, 3, 5);
            ctx.fillRect(2, 5, 3, 5);

            // Corpo de bulbo
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.arc(0, 0, 9, 0, Math.PI * 2);
            ctx.fill();

            // Folhas como bra√ßos
            ctx.fillStyle = leafColor;
            // Folha da esquerda
            ctx.beginPath();
            ctx.moveTo(-7, -2);
            ctx.quadraticCurveTo(-15, -15, -5, -12);
            ctx.fill();
            // Folha da direita
            ctx.beginPath();
            ctx.moveTo(7, -2);
            ctx.quadraticCurveTo(15, -15, 5, -12);
            ctx.fill();

            // Flor na cabe√ßa
            ctx.save();
            ctx.translate(0, -8);

            // Brilho da flor quando pronta
            if (bloomProgress >= 1) {
                const glowPulse = 0.8 + Math.sin(gameTime * 10) * 0.2;
                ctx.globalAlpha *= glowPulse;
                if (currentGraphics && currentGraphics.shadows) {
                    ctx.shadowColor = flowerCoreColor; ctx.shadowBlur = 15;
                }
            }

            // P√©talas
            const petalCount = 5;
            for (let i = 0; i < petalCount; i++) {
                ctx.save();
                ctx.rotate(i * Math.PI * 2 / petalCount);
                ctx.fillStyle = flowerPetalColor;
                ctx.beginPath();
                // As p√©talas se abrem com o progresso
                const angleOffset = (Math.PI / 3) * (1 - bloomProgress);
                ctx.ellipse(0, -6, 4, 6 * bloomProgress, angleOffset, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Miolo da flor
            ctx.fillStyle = flowerCoreColor;
            ctx.beginPath();
            ctx.arc(0, 0, 4, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore(); // Fim do desenho da flor
            ctx.restore(); // Fim do desenho do pet
        }
    }

    class ShadowPupPet extends Pet {
        constructor(player) {
            super(player, 'pup');
            const stats = CONFIG.PETS.shadow_pup;
            this.radiusMultiplier = stats.baseRadius;
            this.player.pickupRadiusMultiplier = this.radiusMultiplier;
            this.trail = [];
        }
        update(dt) {
             // Movimento fluido
            const targetX = this.player.x - (this.player.lastMoveDirection.x * 20);
            const targetY = this.player.y - this.followDistance + 20;
            const lerpFactor = 0.06;
            this.x += (targetX - this.x) * lerpFactor;
            this.y += (targetY - this.y) * lerpFactor;

            // Rastro de fuma√ßa
            this.trail.push({x: this.x, y: this.y, alpha: 1.0, size: 10});
            if(this.trail.length > 15) {
                this.trail.shift();
            }
            this.trail.forEach(p => {
                p.alpha -= dt * 1.5;
                p.size -= dt * 2;
            });


            if (this.player.pickupRadiusMultiplier !== this.radiusMultiplier) {
                 this.player.pickupRadiusMultiplier = this.radiusMultiplier;
            }
        }
        draw(ctx) {
            ctx.save();
            ctx.globalAlpha *= playerData.graphics.effectsOpacity;

            // Aura de coleta no jogador
            const auraRadius = this.player.pickupRadius * this.radiusMultiplier;
            const auraPulse = 0.2 + Math.sin(gameTime * 3) * 0.1;
            ctx.strokeStyle = `rgba(147, 112, 219, ${auraPulse})`;
            ctx.fillStyle = `rgba(147, 112, 219, ${auraPulse * 0.2})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.player.x, this.player.y, auraRadius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fill();

            // Rastro
            this.trail.forEach(p => {
                if (p.size <= 0) return;
                ctx.fillStyle = `rgba(72, 61, 139, ${p.alpha * 0.5})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });

            const bodyColor = `rgba(72, 61, 139, 0.7)`;
            const eyeColor = '#e6e6fa'; // Lavanda p√°lido
             if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = '#9370DB'; ctx.shadowBlur = 15;
            }

            ctx.translate(this.x, this.y);

            // Corpo de fuma√ßa
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.ellipse(0, 0, 14, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // Orelhas
            ctx.beginPath();
            ctx.moveTo(-8, -8); ctx.lineTo(-4, -16); ctx.lineTo(0, -8);
            ctx.moveTo(8, -8); ctx.lineTo(4, -16); ctx.lineTo(0, -8);
            ctx.fill();

            // Cauda
             ctx.beginPath();
            ctx.moveTo(12, 0);
            ctx.quadraticCurveTo(20, -15, 15, -5);
            ctx.fill();

            // Olhos brilhantes
            if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = eyeColor; ctx.shadowBlur = 10;
            }
            ctx.fillStyle = eyeColor;
            ctx.beginPath();
            ctx.arc(-5, -2, 2, 0, Math.PI * 2);
            ctx.arc(5, -2, 2, 0, Math.PI * 2);
            ctx.fill();


            ctx.restore();
        }
    }
        // --- Classes de Colet√°veis e Efeitos ---
        // Efeito visual para a forma√ß√£o do escudo do Golem
    class ShieldFormationEffect {
        constructor(startPos1, startPos2, target) {
            this.p1 = {...startPos1};
            this.p2 = {...startPos2};
            this.target = target;
            this.lifespan = 0.5;
            this.life = this.lifespan;
        }

        update(dt) {
            this.life -= dt;
            const lerpFactor = 1 - (this.life / this.lifespan);
            this.p1.x += (this.target.x - this.p1.x) * lerpFactor;
            this.p1.y += (this.target.y - this.p1.y) * lerpFactor;
            this.p2.x += (this.target.x - this.p2.x) * lerpFactor;
            this.p2.y += (this.target.y - this.p2.y) * lerpFactor;
        }

        draw(ctx) {
            const progress = 1 - (this.life / this.lifespan);
            const alpha = Math.sin(progress * Math.PI);
            ctx.save();
            ctx.globalAlpha = alpha * playerData.graphics.effectsOpacity;

            // Desenha as rochas voando
            ctx.fillStyle = '#696969';
            if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = '#abfffa'; ctx.shadowBlur = 20;
            }
            ctx.beginPath();
            ctx.rect(this.p1.x - 5, this.p1.y - 5, 10, 10);
            ctx.rect(this.p2.x - 5, this.p2.y - 5, 10, 10);
            ctx.fill();

            // Desenha o hex√°gono se formando
            if (progress > 0.7) {
                const hexProgress = (progress - 0.7) / 0.3;
                ctx.strokeStyle = '#abfffa';
                ctx.lineWidth = 4;
                ctx.beginPath();
                const radius = (this.target.size + 8) * hexProgress;
                for (let i = 0; i < 6; i++) {
                    const angle = Math.PI / 3 * i;
                    const x = this.target.x + radius * Math.cos(angle);
                    const y = this.target.y + radius * Math.sin(angle);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
            }

            ctx.restore();
        }
    }
    class Collectible {
        constructor(x, y, size) { this.x = x; this.y = y; this.size = size; this.isCollected = false; }
        update(dt, attractionRadius, speed) {
            const dx = player.x - this.x, dy = player.y - this.y;
            const finalAttractionRadius = (attractionRadius || player.pickupRadius) * player.pickupRadiusMultiplier;
            if (dx * dx + dy * dy < finalAttractionRadius * finalAttractionRadius) {
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 1) {
                    this.x += (dx / dist) * speed * dt;
                    this.y += (dy / dist) * speed * dt;
                }
            }
        }
    }
    class ExpOrb extends Collectible {
        constructor(x, y, value) { super(x, y, 5); this.value = value; }
        update(dt) { super.update(dt, null, 400); }
        draw(ctx) {
            const glowColor = '#4dff9e';
            ctx.save();
            if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = glowColor; ctx.shadowBlur = 8;
            }
            ctx.fillStyle = glowColor;
            ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
        }
    }
    class SoulGem extends Collectible {
        constructor(x, y) { super(x, y, 6); }
        update(dt) { super.update(dt, null, 450); }
        draw(ctx) {
            const size = this.size, glowColor = '#ffff4d';
            ctx.save();
            ctx.translate(this.x, this.y); ctx.rotate(gameTime * 2);
            if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = glowColor; ctx.shadowBlur = 12;
            }
            ctx.fillStyle = glowColor;
            ctx.beginPath();
            ctx.moveTo(0, -size * 1.2); ctx.lineTo(size, 0); ctx.lineTo(0, size * 1.2); ctx.lineTo(-size, 0);
            ctx.closePath(); ctx.fill();
            if (currentGraphics && currentGraphics.shadows) ctx.shadowBlur = 0;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.beginPath();
            ctx.moveTo(0, -size * 0.5); ctx.lineTo(size * 0.4, 0); ctx.lineTo(0, size * 0.5); ctx.lineTo(-size * 0.4, 0);
            ctx.closePath(); ctx.fill();
            ctx.restore();
        }
    }
     class HealingOrb extends Collectible {
        constructor(x, y, value) {
            super(x, y, 8);
            this.value = value;
        }
        update(dt) { super.update(dt, null, 400); }
        draw(ctx) {
            const glowColor = '#ff4d4d';
            ctx.save();
            if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = glowColor; ctx.shadowBlur = 10;
            }
            ctx.fillStyle = glowColor;
            ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '8px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('+', this.x, this.y + 1);
            ctx.restore();
        }
    }
    class Powerup extends Collectible {
        constructor(x, y, size) {
            super(x, y, size);
        }
        update(dt) {
            super.update(dt, null, 500); 
        }
    }
    class HealingFragment extends Powerup {
        constructor(x, y) {
            super(x, y, 10);
            this.healAmount = 0.25;
        }
        draw(ctx) {
            const s = this.size;
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.fillStyle = '#ff4d4d';
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 2;
            if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = '#ff8d8d';
                ctx.shadowBlur = 15;
            }
            ctx.beginPath();
            ctx.moveTo(0, -s / 4);
            ctx.quadraticCurveTo(s / 2, -s / 2, s / 2, 0);
            ctx.quadraticCurveTo(s / 2, s / 2, 0, s / 2);
            ctx.quadraticCurveTo(-s / 2, s / 2, -s / 2, 0);
            ctx.quadraticCurveTo(-s / 2, -s / 2, 0, -s / 4);
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }
    }
    class MagnetFragment extends Powerup {
        constructor(x, y) {
            super(x, y, 12);
        }
        draw(ctx) {
            const s = this.size;
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(-Math.PI / 4);
            ctx.strokeStyle = '#c0c0c0';
            ctx.lineWidth = s / 2.5;
            if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = '#ffffff';
                ctx.shadowBlur = 15;
            }
            ctx.beginPath();
            ctx.arc(0, 0, s / 2, Math.PI, 0);
            ctx.stroke();
            ctx.fillStyle = '#ff4d4d';
            ctx.fillRect(s/2, -s/5, s/4, s/2.5);
            ctx.fillStyle = '#8a8aff';
            ctx.fillRect(-s/2 - s/4, -s/5, s/4, s/2.5);
            ctx.restore();
        }
    }
    class Shrine {
        constructor(x, y, type) {
            this.x = x; this.y = y; this.type = type;
            this.size = 30;
            this.activationRadius = 100;
            this.activationTime = 2.5;
            this.activationProgress = 0;
            this.isDepleted = false;
            this.pulse = 0;

            const types = {
                fury: { color: '#ff4d4d', symbol: '‚öîÔ∏è' },
                protection: { color: '#ffd700', symbol: 'üõ°Ô∏è' },
                wealth: { color: '#ffff4d', symbol: '‚ô¶' }
            };
            this.config = types[type];
        }

        update(dt) {
            if (this.isDepleted) return;

            this.pulse = Math.sin(gameTime * 4);
            const distSq = (player.x - this.x)**2 + (player.y - this.y)**2;

            if (distSq < this.activationRadius**2) {
                this.activationProgress += dt;
                if (this.activationProgress >= this.activationTime) {
                    this.activate();
                }
            } else {
                this.activationProgress = Math.max(0, this.activationProgress - dt * 2); 
            }
        }

        activate() {
            if (this.isDepleted) return;
            this.isDepleted = true;
            soundManager.play('levelUp');
            createParticleBurst(this.x, this.y, 50, this.config.color, 1, 5, 200);

            switch (this.type) {
                case 'fury':
                    player.furyShrineTimer = 30;
                    floatingTexts.push(new FloatingText(player.x, player.y - 30, 'F√öRIA!', this.config.color, 3, 20));
                    break;
                case 'protection':
                    player.protectionShrineTimer = 8;
                    floatingTexts.push(new FloatingText(player.x, player.y - 30, 'PROTE√á√ÉO!', this.config.color, 3, 20));
                    break;
                case 'wealth':
                    player.wealthShrineTimer = 15;
                    floatingTexts.push(new FloatingText(player.x, player.y - 30, 'RIQUEZA!', this.config.color, 3, 20));
                    break;
            }
        }

        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = playerData.graphics.effectsOpacity;

            if (!this.isDepleted) {
                ctx.beginPath();
                ctx.strokeStyle = `rgba(240, 240, 255, ${0.1 + this.pulse * 0.1})`;
                ctx.lineWidth = 3;
                ctx.arc(this.x, this.y, this.activationRadius, 0, Math.PI * 2);
                ctx.stroke();

                if (this.activationProgress > 0) {
                    ctx.beginPath();
                    ctx.fillStyle = `rgba(240, 240, 255, 0.2)`;
                    const angle = (this.activationProgress / this.activationTime) * Math.PI * 2;
                    ctx.moveTo(this.x, this.y);
                    ctx.arc(this.x, this.y, this.activationRadius, -Math.PI / 2, -Math.PI / 2 + angle);
                    ctx.closePath();
                    ctx.fill();
                }
            }

            const s = this.size;
            const yOffset = Math.sin(gameTime * 2) * 5;
            ctx.translate(this.x, this.y + yOffset);

            if(this.isDepleted) ctx.globalAlpha *= 0.3;

            if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = this.config.color;
                ctx.shadowBlur = 15 + this.pulse * 8;
            }

            ctx.fillStyle = this.config.color;
            ctx.beginPath();
            ctx.moveTo(0, -s);
            ctx.lineTo(s, 0);
            ctx.lineTo(0, s);
            ctx.lineTo(-s, 0);
            ctx.closePath();
            ctx.fill();

            if (currentGraphics && currentGraphics.shadows) ctx.shadowBlur = 0;

            ctx.fillStyle = this.isDepleted ? '#333' : '#1a1a2a';
            ctx.beginPath();
            ctx.arc(0, 0, s * 0.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }
    }
    class Particle {
        constructor(x, y, color, lifespan, size, speed) {
            this.x = x; this.y = y; this.color = color; this.lifespan = lifespan; this.size = size;
            const angle = Math.random() * 2 * Math.PI, velocity = Math.random() * speed;
            this.vx = Math.cos(angle) * velocity; this.vy = Math.sin(angle) * velocity;
            this.alpha = 1;
        }
        update(dt) {
            this.x += this.vx * dt; this.y += this.vy * dt;
            this.lifespan -= dt; this.alpha = this.lifespan;
        }
        draw(ctx) {
            ctx.globalAlpha = Math.max(0, this.alpha * playerData.graphics.effectsOpacity); 
            ctx.fillStyle = this.color;
            ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
        }
    }
    class FloatingText {
        constructor(x, y, text, color, lifespan = 1, size = 14) {
            this.x = x; this.y = y; this.text = text; this.color = color;
            this.lifespan = lifespan; this.size = size; this.initialLifespan = lifespan;
            this.vy = -50; this.alpha = 1;
        }
        update(dt) {
            this.y += this.vy * dt;
            this.lifespan -= dt;
            this.alpha = this.lifespan / this.initialLifespan;
        }
        draw(ctx) {
            ctx.globalAlpha = Math.max(0, this.alpha * playerData.graphics.effectsOpacity);
            ctx.fillStyle = this.color;
            ctx.font = `${this.size}px "Press Start 2P"`;
            ctx.fillText(this.text, this.x, this.y);
        }
    }
    class Shockwave {
        constructor(x, y, radius, damage) {
            this.x = x; this.y = y; this.maxRadius = radius; this.damage = damage;
            this.lifespan = 0.4; this.life = this.lifespan; this.hitEnemies = [];
        }
        update(dt) {
            this.life -= dt;
            const progress = 1 - (this.life / this.lifespan);
            const currentRadius = this.maxRadius * progress;
            enemies.forEach(enemy => {
                if (!this.hitEnemies.includes(enemy)) { 
                    const distSq = (enemy.x - this.x)**2 + (enemy.y - this.y)**2;
                    if (distSq < currentRadius**2) {
                        enemy.takeDamage(this.damage);
                        this.hitEnemies.push(enemy);
                    }
                }
            });
        }
        draw(ctx) {
            const progress = 1 - (this.life / this.lifespan);
            const currentRadius = this.maxRadius * progress;
            ctx.save();
            ctx.globalAlpha = playerData.graphics.effectsOpacity;
            ctx.strokeStyle = `rgba(255, 255, 200, ${this.life / this.lifespan})`;
            ctx.lineWidth = 10 * (this.life / this.lifespan);
            if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 20;
            }
            ctx.beginPath();
            ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }
    }
    class WarningCircle {
        constructor(x, y, radius, duration, onEndCallback) {
            this.x = x; this.y = y; this.radius = radius; this.lifespan = duration;
            this.life = duration; this.onEndCallback = onEndCallback;
        }
        update(dt) {
            this.life -= dt;
            if (this.life <= 0) {
                this.onEndCallback(this.x, this.y);
            }
        }
        draw(ctx) {
            const progress = 1 - (this.life / this.lifespan);
            ctx.save();
            ctx.globalAlpha = (0.5 + Math.sin(progress * Math.PI) * 0.3) * playerData.graphics.effectsOpacity;
            ctx.fillStyle = `rgba(255, 50, 100, ${0.2 + progress * 0.3})`;
            ctx.strokeStyle = `rgba(255, 80, 120, 1)`;
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            ctx.strokeStyle = `rgba(255, 255, 255, 0.8)`;
            ctx.lineWidth = 10;
            ctx.beginPath();
            ctx.arc(this.x, this.y, 50 * (this.life / this.lifespan), 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }
    }
    class LavaPool {
        constructor(x, y, radius, dps, duration) {
            this.x = x; this.y = y; this.radius = radius; this.dps = dps;
            this.lifespan = duration; this.life = duration;
            this.damageTimer = 0.5;
        }
        update(dt) {
            this.life -= dt;
            this.damageTimer -= dt;
            if (this.damageTimer <= 0) {
                if ((player.x - this.x)**2 + (player.y - this.y)**2 < this.radius**2) {
                    player.takeDamage(this.dps * 0.5);
                }
                this.damageTimer = 0.5;
            }
        }
        draw(ctx) {
            const alpha = Math.min(1, this.life / this.lifespan * 2);
            ctx.save();
            ctx.globalAlpha = alpha * playerData.graphics.effectsOpacity;
            const color = `rgba(255, 100, 0, ${0.4 + Math.sin(gameTime * 10) * 0.1})`;
            ctx.fillStyle = color;
            if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = '#ff4500';
                ctx.shadowBlur = 20;
            }
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
    }
        // COLE ESTAS DUAS NOVAS CLASSES NO SEU C√ìDIGO
    class ParryEffect {
        constructor(player) {
            this.player = player;
            this.lifespan = CONFIG.PLAYER.parryDuration;
            this.life = this.lifespan;
            this.maxRadius = player.size * 1.5;
        }
        update(dt) {
            this.life -= dt;
        }
        draw(ctx) {
            const progress = 1 - (this.life / this.lifespan);
            // Efeito de "pop" (cresce r√°pido e encolhe)
            const radius = this.maxRadius * Math.sin(progress * Math.PI);
            const alpha = Math.sin(progress * Math.PI) * 0.8;

            ctx.save();
            ctx.globalAlpha = alpha * playerData.graphics.effectsOpacity;
            ctx.strokeStyle = '#ffffff';
            ctx.fillStyle = 'rgba(200, 220, 255, 0.5)';
            ctx.lineWidth = 4;
            if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = '#ffffff';
                ctx.shadowBlur = 25;
            }

            // Desenha um hex√°gono de energia
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i + (gameTime * 5); // Adiciona rota√ß√£o
                const x = this.player.x + radius * Math.cos(angle);
                const y = this.player.y + radius * Math.sin(angle);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.stroke();
            ctx.fill();
            ctx.restore();
        }
    }

    class PushWaveEffect {
        constructor(x, y, radius) {
            this.x = x;
            this.y = y;
            this.maxRadius = radius;
            this.lifespan = 0.4;
            this.life = this.lifespan;
        }
        update(dt) {
            this.life -= dt;
        }
        draw(ctx) {
            const progress = 1 - (this.life / this.lifespan);
            const currentRadius = this.maxRadius * progress;
            const alpha = this.life / this.lifespan;

            ctx.save();
            ctx.globalAlpha = alpha * playerData.graphics.effectsOpacity;
            ctx.strokeStyle = '#ffffff';
            // A onda fica mais fina conforme se expande
            ctx.lineWidth = 10 * (1 - progress);
             if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = '#ffffff';
                ctx.shadowBlur = 20;
            }
            ctx.beginPath();
            ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }
    }
        class LightningBolt {
        constructor(points, isEvolved) {
            this.points = points;
            this.lifespan = isEvolved ? 0.45 : 0.25;
            this.life = this.lifespan;
            this.isEvolved = isEvolved;
        }
        update(dt) { this.life -= dt; }
        draw(ctx) {
            const alpha = this.life / this.lifespan;
            ctx.save();
            ctx.globalAlpha = alpha * playerData.graphics.effectsOpacity;
            if (this.isEvolved) {
                 if (currentGraphics && currentGraphics.shadows) {
                    ctx.shadowColor = '#ffffff';
                    ctx.shadowBlur = 30;
                }
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 8;
                this.drawBoltPath(ctx, 20);

                ctx.strokeStyle = '#87cefa';
                ctx.lineWidth = 15;
                 if (currentGraphics && currentGraphics.shadows) {
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = '#4dffff';
                }
                this.drawBoltPath(ctx, 25);
            } 
            else {
                ctx.lineWidth = 3;
                ctx.strokeStyle = '#ffffff';
                 if (currentGraphics && currentGraphics.shadows) {
                    ctx.shadowColor = '#4dffff';
                    ctx.shadowBlur = 20;
                }
                 this.drawBoltPath(ctx, 10);
            }

            ctx.restore();
        }

        drawBoltPath(ctx, randomOffset) {
             for (let i = 0; i < this.points.length - 1; i++) {
                const start = this.points[i];
                const end = this.points[i + 1];
                ctx.beginPath();
                ctx.moveTo(start.x, start.y);
                const segments = 10;
                for (let j = 1; j <= segments; j++) {
                    const t = j / segments;
                    const x = start.x * (1 - t) + end.x * t;
                    const y = start.y * (1 - t) + end.y * t;
                    const offsetX = (Math.random() - 0.5) * randomOffset * Math.sin(t * Math.PI);
                    const offsetY = (Math.random() - 0.5) * randomOffset * Math.sin(t * Math.PI);
                    ctx.lineTo(x + offsetX, y + offsetY);
                }
                ctx.stroke();
            }
        }
    }
    class SpectralArc {
        constructor(x, y, angle, arc, range, damage, isEvolved = false) {
            this.x = x; this.y = y; this.angle = angle;
            this.arc = isEvolved ? Math.PI * 2 : arc;
            this.range = range; this.damage = damage;
            this.lifespan = isEvolved ? 0.4 : 0.25;
            this.life = this.lifespan;
            this.hitEnemies = [];
            this.isEvolved = isEvolved;
            this.initialRotation = Math.random() * Math.PI;
        }
        update(dt) {
            this.life -= dt;
            const startAngle = this.angle - this.arc / 2;
            enemies.forEach(enemy => {
                if (!this.hitEnemies.includes(enemy)) {
                    const dx = enemy.x - this.x;
                    const dy = enemy.y - this.y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq < this.range * this.range) {
                        if (this.isEvolved) {
                            enemy.takeDamage(this.damage);
                            this.hitEnemies.push(enemy);
                            return;
                        }
                        let enemyAngle = Math.atan2(dy, dx);
                        let angleDiff = enemyAngle - startAngle;
                        while(angleDiff < 0) angleDiff += Math.PI * 2;
                        while(angleDiff > Math.PI*2) angleDiff -= Math.PI * 2;

                        if (angleDiff <= this.arc) {
                             enemy.takeDamage(this.damage);
                             this.hitEnemies.push(enemy);
                        }
                    }
                }
            });
        }
        draw(ctx) {
            const progress = this.life / this.lifespan;
            ctx.save();
            ctx.globalAlpha = progress * playerData.graphics.effectsOpacity;
            ctx.translate(this.x, this.y);

            if (this.isEvolved) {
                const rotation = gameTime * 15 + this.initialRotation;
                const bladeCount = 5;
                if (currentGraphics && currentGraphics.shadows) {
                    ctx.shadowColor = '#ffffff';
                    ctx.shadowBlur = 30;
                }
                for(let i=0; i < bladeCount; i++) {
                    ctx.save();
                    ctx.rotate(rotation + (i * Math.PI * 2 / bladeCount));
                    const grad = ctx.createLinearGradient(0, 0, this.range, 0);
                    grad.addColorStop(0, 'rgba(255, 255, 255, 0)');
                    grad.addColorStop(0.7, 'rgba(170, 255, 255, 0.8)');
                    grad.addColorStop(1, 'rgba(255, 255, 255, 0.9)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.moveTo(0,0);
                    ctx.lineTo(this.range * 0.8, -10);
                    ctx.lineTo(this.range, 0);
                    ctx.lineTo(this.range * 0.8, 10);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                }
            }
            else {
                if (currentGraphics && currentGraphics.shadows) {
                    ctx.shadowColor = '#aaffff';
                    ctx.shadowBlur = 20;
                }
                const grad = ctx.createRadialGradient(0,0,0, 0,0,this.range);
                grad.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                grad.addColorStop(0.8, 'rgba(170, 255, 255, 0.6)');
                grad.addColorStop(1, 'rgba(170, 255, 255, 0)');
                ctx.fillStyle = grad;

                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.arc(0, 0, this.range, this.angle - this.arc / 2, this.angle + this.arc / 2);
                ctx.closePath();
                ctx.fill();
            }

            ctx.restore();
        }
    }
        // --- Sistema de Armas ---
    class Projectile {
        constructor(x, y, target, speed, damage, pierce, size, color, options = {}) {
            this.x = x; this.y = y; this.speed = speed; this.damage = damage; this.pierce = pierce; this.size = size; this.color = color;
            this.hitEnemies = []; this.lifetime = options.lifetime || 3;
            const dir = target; 
            this.vx = dir.x * speed; this.vy = dir.y * speed; this.particleTimer = 0;
            this.explodes = options.explodes || false;
            this.explosionRadius = options.explosionRadius || 50;
                        this.pulls = options.pulls || false;
            this.pullRadius = options.pullRadius || 0;
            this.pullStrength = options.pullStrength || 100;

            this.weaponId = options.weaponId || null;
            this.isEvolved = options.isEvolved || false;
            this.rotation = Math.atan2(this.vy, this.vx);
        }
        update(dt) { 
            this.x += this.vx * dt; this.y += this.vy * dt; 
            this.lifetime -= dt; this.particleTimer -= dt;
            if (this.particleTimer <= 0 && this.weaponId === 'fireball') {
                this.particleTimer = 0.03;
                const particleColor = this.isEvolved ? 'rgba(180, 220, 255, 0.7)' : (Math.random() < 0.5 ? 'rgba(255, 100, 0, 0.7)' : 'rgba(255, 200, 0, 0.7)');
                createParticleBurst(this.x, this.y, 1, particleColor, 0.4, this.size * 0.6, 50);
            }
                        if (this.pulls) {
                const pullAngle = gameTime * (this.isEvolved ? -10 : 8);
                const particleCount = this.isEvolved ? 3 : 1;
                for(let i=0; i < particleCount; i++) {
                    const angle = pullAngle + (i * Math.PI*2 / particleCount);
                    const pX = this.x + Math.cos(angle) * this.pullRadius * (this.lifetime / 2);
                    const pY = this.y + Math.sin(angle) * this.pullRadius * (this.lifetime / 2);
                    particles.push(new Particle(pX, pY, this.isEvolved ? '#ff00ff' : '#dcb0ff', 0.2, 2, -400));
                }

                enemies.forEach(enemy => {
                    if (enemy.isBoss) return;
                    const dx = this.x - enemy.x;
                    const dy = this.y - enemy.y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq < this.pullRadius ** 2 && distSq > enemy.size**2) {
                        const dist = Math.sqrt(distSq);
                        enemy.x += (dx / dist) * this.pullStrength * (1 - dist/this.pullRadius) * dt;
                        enemy.y += (dy / dist) * this.pullStrength * (1 - dist/this.pullRadius) * dt;
                    }
                });
            }
        }
        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = playerData.graphics.effectsOpacity;

            switch(this.weaponId) {
                case 'fireball': this.drawFireball(ctx); break;
                case 'singularity_cannon': this.drawSingularity(ctx); break;
                default: this.drawDefault(ctx); break;
            }

            ctx.restore();
        }
        drawDefault(ctx) {
            if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = this.color; ctx.shadowBlur = 12;
            }
            ctx.fillStyle = this.color;
            ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
        }
        drawFireball(ctx) {
            if (this.isEvolved) {
                const coreColor = '#ffffff';
                const glowColor = 'rgba(100, 180, 255, 0.7)';
                if (currentGraphics && currentGraphics.shadows) {
                    ctx.shadowColor = glowColor; ctx.shadowBlur = this.size * 3;
                }
                const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                grad.addColorStop(0, coreColor);
                grad.addColorStop(0.5, glowColor);
                grad.addColorStop(1, 'rgba(100, 180, 255, 0)');
                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size * 1.5, 0, Math.PI * 2); ctx.fill();
            } 
            else {
                const coreColor = '#ffffaa';
                const glowColor = this.color;
                if (currentGraphics && currentGraphics.shadows) {
                    ctx.shadowColor = glowColor; ctx.shadowBlur = this.size * 2;
                }
                const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                grad.addColorStop(0, coreColor);
                grad.addColorStop(0.6, glowColor);
                grad.addColorStop(1, 'rgba(255, 140, 26, 0)');
                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size * 1.2, 0, Math.PI * 2); ctx.fill();
            }
        }
        drawSingularity(ctx) {
             if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = this.isEvolved ? '#ff00ff' : this.color; 
                ctx.shadowBlur = this.size * 3;
            }
            if (this.isEvolved) {
                const coreGrad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                coreGrad.addColorStop(0, '#2e0854');
                coreGrad.addColorStop(1, '#000000');
                ctx.fillStyle = coreGrad;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();

                ctx.strokeStyle = '#ff00ff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 1.5, 0, Math.PI * 2);
                ctx.stroke();
            }
            else {
                const grad = ctx.createRadialGradient(this.x, this.y, this.size * 0.2, this.x, this.y, this.size);
                grad.addColorStop(0, '#000000');
                grad.addColorStop(0.8, this.color);
                grad.addColorStop(1, 'rgba(148, 0, 211, 0)');
                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
            }
        }
        handleExplosion() {
            if (!this.explodes) return;
            const particleColor = this.isEvolved && this.weaponId === 'fireball' ? '#87cefa' : this.color;
            createParticleBurst(this.x, this.y, 30, particleColor, 0.8, 6, 250);
            camera.startShake(8, 0.15);
            enemies.forEach(enemy => {
                if ((enemy.x - this.x)**2 + (enemy.y - this.y)**2 < this.explosionRadius**2) {
                    enemy.takeDamage(this.damage);
                }
            });
        }
    }
    class EnergyBall {
        constructor(x, y, target, speed, damage) {
            this.x = x; this.y = y; this.speed = speed; this.damage = damage; this.size = 10;
            this.color = '#d07aff'; this.lifetime = 4;
            const dir = normalizeVector({x: target.x - x, y: target.y - y});
            this.vx = dir.x * speed; this.vy = dir.y * speed; this.particleTimer = 0;
        }
        update(dt) {
            this.x += this.vx * dt; this.y += this.vy * dt; this.lifetime -= dt; this.particleTimer -= dt;
            if (this.particleTimer <= 0) {
                this.particleTimer = 0.03;
                const particleColor = Math.random() < 0.5 ? 'rgba(190, 77, 255, 0.7)' : 'rgba(230, 180, 255, 0.7)';
                createParticleBurst(this.x, this.y, 1, particleColor, 0.4, this.size * 0.8, 60);
            }
        }
        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = playerData.graphics.effectsOpacity;
            if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = '#be4dff'; ctx.shadowBlur = 15;
            }
            ctx.fillStyle = 'rgba(190, 77, 255, 0.8)';
            ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
            if (currentGraphics && currentGraphics.shadows) ctx.shadowBlur = 8;
            ctx.fillStyle = 'rgba(255, 255, 255, 1)';
            ctx.beginPath(); ctx.arc(this.x, this.y, this.size * 0.4, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
        }
    }
   class HomingSoul extends EnergyBall {
        constructor(x, y, target, speed, damage, firedBy = 'enemy') {
            super(x, y, target, speed, damage);
            this.target = target;
            this.firedBy = firedBy; // 'player' or 'enemy'
            this.turnSpeed = Math.PI * 0.9; 
            this.color = 'rgba(150, 220, 255, 0.8)';
            this.size = 12; this.acceleration = 90; 
            this.lifetime = 6;
            this.isPet = false;
            this.isWispFire = false; // Flag para o novo visual
            this.trail = [];
        }
        update(dt) {
            if (this.firedBy === 'player' && !this.target?.isAlive) {
                this.target = findNearestEnemy(this, false) || this.target;
            }
            if(!this.target || !this.target.isAlive) {
                this.lifetime = 0;
                return;
            }

            // Adiciona pontos √† cauda (trail)
            if (this.isWispFire) {
                this.trail.push({x: this.x, y: this.y, alpha: 1.0});
                if(this.trail.length > 10) {
                    this.trail.shift();
                }
                this.trail.forEach(p => p.alpha -= dt * 2);
            }

            this.speed += this.acceleration * dt;
            const targetAngle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
            let currentAngle = Math.atan2(this.vy, this.vx);
            let angleDiff = targetAngle - currentAngle;
            while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
            while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
            const turnAmount = this.turnSpeed * dt;
            if (Math.abs(angleDiff) < turnAmount) {
                currentAngle = targetAngle;
            } else {
                currentAngle += Math.sign(angleDiff) * turnAmount;
            }
            this.vx = Math.cos(currentAngle) * this.speed;
            this.vy = Math.sin(currentAngle) * this.speed;
            this.x += this.vx * dt; this.y += this.vy * dt; this.lifetime -= dt;
        }
        draw(ctx){
            if (this.isWispFire) {
                this.drawWispFire(ctx);
            } else {
                ctx.save();
                ctx.globalAlpha = playerData.graphics.effectsOpacity;
                if (currentGraphics && currentGraphics.shadows) {
                    ctx.shadowColor = this.color; ctx.shadowBlur = 15;
                }
                ctx.fillStyle = this.color;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
                if (currentGraphics && currentGraphics.shadows) ctx.shadowBlur = 8;
                ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size * 0.4, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            }
        }
        drawWispFire(ctx) {
            ctx.save();
            ctx.globalAlpha *= playerData.graphics.effectsOpacity;

            // Cauda de fuma√ßa e brasas
            for (let i = 0; i < this.trail.length; i++) {
                const p = this.trail[i];
                const progress = i / this.trail.length;
                ctx.fillStyle = `rgba(255, 100, 0, ${p.alpha * 0.5 * progress})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, this.size * progress, 0, Math.PI * 2);
                ctx.fill();
            }

            // Alma flamejante (cabe√ßa do proj√©til)
            const color = '#ff8c1a';
            const coreColor = '#ffffaa';
            if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = color; ctx.shadowBlur = this.size * 2;
            }
            const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
            grad.addColorStop(0, coreColor);
            grad.addColorStop(0.6, color);
            grad.addColorStop(1, 'rgba(255, 140, 26, 0)');
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();

            ctx.restore();
        }
    }
    class MagmaBall extends EnergyBall {
        constructor(x, y, target, speed, damage) {
            super(x, y, target, speed, damage);
            this.color = '#ff8c00';
            this.size = 25;
            this.lifetime = 6;
        }
        update(dt) {
            super.update(dt);
            if (Math.random() < 0.2) {
                 createParticleBurst(this.x, this.y, 1, 'rgba(255, 69, 0, 0.6)', 0.5, 5, 30);
            }
            const outOfBoundsX = this.x < 0 || this.x > CONFIG.MAP_SIZE.width;
            const outOfBoundsY = this.y < 0 || this.y > CONFIG.MAP_SIZE.height;
            if (this.lifetime <= 0 || outOfBoundsX || outOfBoundsY) {
                 effects.push(new LavaPool(this.x, this.y, 100, 20, 5));
                 this.lifetime = 0;
            }
        }
        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = playerData.graphics.effectsOpacity;
            if (currentGraphics && currentGraphics.shadows) {
                ctx.shadowColor = this.color; ctx.shadowBlur = 20;
            }
            ctx.fillStyle = this.color;
            ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
        }
    }
        // --- Fun√ß√µes Auxiliares e de Jogo ---
    class AmbientParticle {
        constructor() {
            this.x = Math.random() * CONFIG.MAP_SIZE.width;
            this.y = Math.random() * CONFIG.MAP_SIZE.height;
            this.size = Math.random() * 1.5 + 1;
            this.baseY = this.y;
            this.speedX = (Math.random() - 0.5) * 15; 
            this.amplitudeY = Math.random() * 10 + 5; 
            this.frequencyY = Math.random() * 0.5 + 0.2; 
            this.color = `rgba(200, 220, 255, ${Math.random() * 0.4 + 0.2})`;
        }
        update(dt) {
            this.x += this.speedX * dt;
            this.y = this.baseY + Math.sin(gameTime * this.frequencyY) * this.amplitudeY;
            if (this.x < 0) this.x = CONFIG.MAP_SIZE.width;
            if (this.x > CONFIG.MAP_SIZE.width) this.x = 0;
        }
        draw(ctx) {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }
        // --- Sistema de Armas ---
    class FireballWeapon {
        constructor(player) {
            this.id = 'fireball'; this.player = player;
            this.stats = { ...CONFIG.WEAPONS.fireball };
            this.cooldownTimer = 0; this.isEvolved = false;
        }
        update(dt) {
            const attackSpeedMultiplier = this.player.furyShrineTimer > 0 ? 2 : 1;
            this.cooldownTimer -= dt * attackSpeedMultiplier;
            if (this.cooldownTimer <= 0) { this.attack(); this.cooldownTimer = this.stats.cooldown; }
        }
        attack() {
            const target = findNearestEnemy(this.player, false, this.stats.initialRange);
            if (!target) return;
            soundManager.play('shot');
            const totalDamage = this.stats.damage * this.player.damageMultiplier;
            const options = {
                weaponId: this.id,
                isEvolved: this.isEvolved,
                explodes: this.isEvolved,
                explosionRadius: 75
            };
            if (this.isEvolved) {
                const baseDir = normalizeVector({x: target.x - this.player.x, y: target.y - this.player.y});
                const angle = Math.atan2(baseDir.y, baseDir.x);
                const spread = Math.PI / 8; 
                for (let i = -1; i <= 1; i++) {
                    const currentAngle = angle + i * spread;
                    const dir = {x: Math.cos(currentAngle), y: Math.sin(currentAngle)};
                    projectiles.push(new Projectile(this.player.x, this.player.y, dir, this.stats.speed, totalDamage, this.stats.pierce, this.stats.size * 1.5, this.stats.color, options));
                }
            } else {
                const dir = normalizeVector({x: target.x - this.player.x, y: target.y - this.player.y});
                projectiles.push(new Projectile(this.player.x, this.player.y, dir, this.stats.speed, totalDamage, this.stats.pierce, this.stats.size, this.stats.color, options));
            }
        }
        evolve() {
            this.isEvolved = true;
            this.stats.cooldown *= 1.2;
            playerData.persistentStats.weaponsEvolved = (playerData.persistentStats.weaponsEvolved || 0) + 1;
        }
        draw(ctx) {}
    }
    class HammerWeapon {
        constructor(player) {
            this.id = 'hammer'; this.player = player;
            this.stats = { ...CONFIG.WEAPONS.hammer };
            this.hammers = []; this.hitCooldown = 0.75;
            this.hitEnemies = new Map(); this.isEvolved = false;
            this.shockwaveTimer = 0; this.shockwaveCooldown = 5;
            this.recalculateHammers();
        }
        recalculateHammers() {
            this.hammers = [];
            for (let i = 0; i < this.stats.count; i++) {
                this.hammers.push({ angle: (Math.PI * 2 / this.stats.count) * i });
            }
        }
        addHammer() { this.recalculateHammers(); }
        evolve() {
            this.isEvolved = true;
            this.stats.size *= 1.5;
            playerData.persistentStats.weaponsEvolved = (playerData.persistentStats.weaponsEvolved || 0) + 1;
        }
        update(dt) {
            const attackSpeedMultiplier = this.player.furyShrineTimer > 0 ? 2 : 1;
            this.hammers.forEach(hammer => hammer.angle += this.stats.rotationSpeed * dt * attackSpeedMultiplier);
            for (const [enemy, timer] of this.hitEnemies.entries()) {
                if (timer - dt <= 0) this.hitEnemies.delete(enemy);
                else this.hitEnemies.set(enemy, timer - dt);
            }
            if (this.isEvolved) {
                this.shockwaveTimer -= dt;
                if (this.shockwaveTimer <= 0) {
                    effects.push(new Shockwave(this.player.x, this.player.y, 200, this.stats.damage * this.player.damageMultiplier * 2));
                    this.shockwaveTimer = this.shockwaveCooldown;
                    camera.startShake(8, 0.2);
                }
            }
            const s = this.stats.size;
            let headWidth = s;
            const effectiveRadius = this.stats.radius;
            for (const hammer of this.hammers) {
                const hammerHeadX = this.player.x + Math.cos(hammer.angle) * effectiveRadius;
                const hammerHeadY = this.player.y + Math.sin(hammer.angle) * effectiveRadius;
                for (const enemy of enemies) {
                    if (this.hitEnemies.has(enemy)) continue;
                    const distSq = (hammerHeadX - enemy.x)**2 + (hammerHeadY - enemy.y)**2;
                    if (distSq < (headWidth / 2 + enemy.size / 2)**2) {
                        enemy.takeDamage(this.stats.damage * this.player.damageMultiplier);
                        soundManager.play('hit');
                        this.hitEnemies.set(enemy, this.hitCooldown);
                    }
                };
            };
        }
        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = playerData.graphics.effectsOpacity;
            this.hammers.forEach(hammer => {
                const hammerX = this.player.x + Math.cos(hammer.angle) * this.stats.radius;
                const hammerY = this.player.y + Math.sin(hammer.angle) * this.stats.radius;
                ctx.save();
                ctx.translate(hammerX, hammerY);
                ctx.rotate(hammer.angle + Math.PI / 2); 
                const s = this.stats.size;

                if (this.isEvolved) {
                    const headColor = '#ffd700';
                    const handleColor = '#d2b48c';
                    const gemColor = '#ff4d4d';
                    if (currentGraphics && currentGraphics.shadows) {
                        ctx.shadowColor = headColor; ctx.shadowBlur = 25;
                    }
                    ctx.fillStyle = handleColor;
                    ctx.fillRect(-s * 0.1, 0, s * 0.2, s * 1.2);
                    ctx.fillStyle = headColor;
                    ctx.fillRect(-s*0.3, -s*0.1, s*0.6, s*0.2);
                    ctx.beginPath();
                    ctx.moveTo(-s/2, -s*0.8);
                    ctx.lineTo(s/2, -s*0.8);
                    ctx.lineTo(s*0.4, -s*0.1);
                    ctx.lineTo(-s*0.4, -s*0.1);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = gemColor;
                    ctx.beginPath();
                    ctx.arc(0, -s*0.45, s*0.15, 0, Math.PI * 2);
                    ctx.fill();
                } 
                else {
                    const headColor = this.stats.color;
                    const handleColor = '#8B4513';
                    if (currentGraphics && currentGraphics.shadows) {
                        ctx.shadowColor = headColor; ctx.shadowBlur = 10;
                    }
                    ctx.fillStyle = handleColor;
                    ctx.fillRect(-s * 0.1, 0, s * 0.2, s * 1.2);
                    ctx.fillStyle = headColor;
                    ctx.fillRect(-s / 2, -s * 0.7, s, s * 0.7);
                }

                ctx.restore();
            });
            ctx.restore();
        }
    }
    class LightningChainWeapon {
        constructor(player) {
            this.id = 'lightning_chain';
            this.player = player;
            this.stats = { ...CONFIG.WEAPONS.lightning_chain };
            this.cooldownTimer = 0;
            this.isEvolved = false;
        }
        update(dt) {
            const attackSpeedMultiplier = this.player.furyShrineTimer > 0 ? 2 : 1;
            this.cooldownTimer -= dt * attackSpeedMultiplier;
            if (this.cooldownTimer <= 0) {
                this.attack();
                this.cooldownTimer = this.stats.cooldown;
            }
        }
        attack() {
            let availableEnemies = [...enemies];
            let firstTarget = findNearestEnemy(this.player, false, this.stats.initialRange);
            if (!firstTarget) return;
            soundManager.play('shot');
            let currentTarget = firstTarget;
            let currentDamage = this.stats.damage * this.player.damageMultiplier;
            let chainedEnemies = [currentTarget];
            let chainPoints = [{x: this.player.x, y: this.player.y}, {x: currentTarget.x, y: currentTarget.y}];
            currentTarget.takeDamage(currentDamage);
            if (this.isEvolved) currentTarget.applyStun(0.5);
            for (let i = 0; i < this.stats.chains; i++) {
                availableEnemies = availableEnemies.filter(e => !chainedEnemies.includes(e));
                let nextTarget = null;
                let nearestDistSq = Infinity;
                for (const potentialTarget of availableEnemies) {
                    const distSq = (currentTarget.x - potentialTarget.x)**2 + (currentTarget.y - potentialTarget.y)**2;
                    if (distSq < this.stats.chainRadius**2 && distSq < nearestDistSq) {
                        nearestDistSq = distSq;
                        nextTarget = potentialTarget;
                    }
                }
                if (nextTarget) {
                    if (!this.isEvolved) {
                       currentDamage *= this.stats.damageFalloff;
                    }
                    nextTarget.takeDamage(currentDamage);
                    if (this.isEvolved) nextTarget.applyStun(0.5);
                    chainedEnemies.push(nextTarget);
                    chainPoints.push({x: nextTarget.x, y: nextTarget.y});
                    currentTarget = nextTarget;
                } else {
                    break;
                }
            }
            effects.push(new LightningBolt(chainPoints, this.isEvolved));
        }
        evolve() {
            this.isEvolved = true;
            this.stats.cooldown *= 0.7; 
            playerData.persistentStats.weaponsEvolved = (playerData.persistentStats.weaponsEvolved || 0) + 1;
        }
        draw(ctx) {}
    }
    class SpectralBladesWeapon {
        constructor(player) {
            this.id = 'spectral_blades'; this.player = player;
            this.stats = { ...CONFIG.WEAPONS.spectral_blades };
            this.cooldownTimer = 0; this.isEvolved = false;
        }
        update(dt) {
            const attackSpeedMultiplier = this.player.furyShrineTimer > 0 ? 2 : 1;
            this.cooldownTimer -= dt * attackSpeedMultiplier;
            if (this.cooldownTimer <= 0) {
                this.attack();
                this.cooldownTimer = this.stats.cooldown;
            }
        }
        attack() {
            const totalDamage = this.stats.damage * this.player.damageMultiplier;
            const attackAngle = Math.atan2(this.player.lastMoveDirection.y, this.player.lastMoveDirection.x);

            for (let i = 0; i < this.stats.count; i++) {
                setTimeout(() => {
                    soundManager.play('shot');
                    const arc = new SpectralArc(this.player.x, this.player.y, attackAngle, this.stats.arc, this.stats.range, totalDamage, this.isEvolved);
                    effects.push(arc);
                }, i * 100);
            }
        }
        evolve() {
            this.isEvolved = true;
            this.stats.cooldown *= 0.8;
            playerData.persistentStats.weaponsEvolved = (playerData.persistentStats.weaponsEvolved || 0) + 1;
        }
        draw(ctx) {}
    }
    class SingularityCannonWeapon {
        constructor(player) {
            this.id = 'singularity_cannon'; this.player = player;
            this.stats = { ...CONFIG.WEAPONS.singularity_cannon };
            this.cooldownTimer = 0; this.isEvolved = false;
        }
        update(dt) {
            const attackSpeedMultiplier = this.player.furyShrineTimer > 0 ? 2 : 1;
            this.cooldownTimer -= dt * attackSpeedMultiplier;
            if (this.cooldownTimer <= 0) {
                this.attack();
                this.cooldownTimer = this.stats.cooldown;
            }
        }
        attack() {
            const target = findNearestEnemy(this.player, false, 1000);
            if (!target) return;
            soundManager.play('shot');
            const totalDamage = this.stats.damage * this.player.damageMultiplier;
            const dir = normalizeVector({x: target.x - this.player.x, y: target.y - this.player.y});

            const options = {
                weaponId: this.id,
                isEvolved: this.isEvolved,
                pulls: true,
                pullRadius: this.stats.pullRadius,
                pullStrength: this.isEvolved ? 300 : 150,
                explodes: true,
                explosionRadius: this.stats.explosionRadius,
                lifetime: this.isEvolved ? 4 : 2,
            };
            projectiles.push(new Projectile(this.player.x, this.player.y, dir, this.stats.speed, totalDamage, 999, this.stats.size, this.stats.color, options));
        }
        evolve() {
            this.isEvolved = true;
            this.stats.pullRadius *= 1.5;
            this.stats.explosionRadius *= 1.5;
            this.stats.damage *= 1.5;
            playerData.persistentStats.weaponsEvolved = (playerData.persistentStats.weaponsEvolved || 0) + 1;
        }
        draw(ctx) {}
    }
    class RunicOrbWeapon {
        constructor(player) {
            this.id = 'runic_orb'; this.player = player;
            this.stats = { ...CONFIG.WEAPONS.runic_orb };
            this.cooldownTimer = 0; this.isEvolved = false;
            this.orbs = [{ angle: 0, dist: 60, cooldown: Math.random() * this.stats.cooldown }];
        }
        update(dt) {
            const attackSpeedMultiplier = this.player.furyShrineTimer > 0 ? 2 : 1;
            this.orbs.forEach(orb => {
                orb.angle += 2 * dt;
                orb.cooldown -= dt * attackSpeedMultiplier;
                if (orb.cooldown <= 0) {
                    const target = findNearestEnemy(this.player, false, 500);
                    if (target) {
                        const orbX = this.player.x + Math.cos(orb.angle) * orb.dist;
                        const orbY = this.player.y + Math.sin(orb.angle) * orb.dist;
                        const proj = new HomingSoul(orbX, orbY, target, this.stats.speed, this.stats.damage * this.player.damageMultiplier, 'player');
                        if(this.isEvolved) proj.pierce = 2;
                        enemyProjectiles.push(proj);
                        orb.cooldown = this.stats.cooldown;
                    }
                }
            });
        }
        evolve() {
            if (this.isEvolved) return;
            this.isEvolved = true;
            this.orbs.push({ angle: Math.PI, dist: 60, cooldown: Math.random() * this.stats.cooldown });
            playerData.persistentStats.weaponsEvolved = (playerData.persistentStats.weaponsEvolved || 0) + 1;
        }
        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = playerData.graphics.effectsOpacity;
            this.orbs.forEach(orb => {
                const orbX = this.player.x + Math.cos(orb.angle) * orb.dist;
                const orbY = this.player.y + Math.sin(orb.angle) * orb.dist;

                if (this.isEvolved) {
                    const eyeColor = '#ff1493';
                    if (currentGraphics && currentGraphics.shadows) {
                        ctx.shadowColor = eyeColor;
                        ctx.shadowBlur = 20;
                    }
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath(); ctx.arc(orbX, orbY, this.stats.size * 1.8, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = eyeColor;
                    ctx.beginPath(); ctx.arc(orbX, orbY, this.stats.size * 1.5, 0, Math.PI * 2); ctx.fill();
                    const target = findNearestEnemy({x: orbX, y: orbY}, false, 500);
                    let pupilX = orbX, pupilY = orbY;
                    if (target) {
                        const dx = target.x - orbX, dy = target.y - orbY;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        pupilX += (dx/dist) * this.stats.size * 0.4;
                        pupilY += (dy/dist) * this.stats.size * 0.4;
                    }
                    ctx.fillStyle = '#000000';
                    ctx.beginPath(); ctx.arc(pupilX, pupilY, this.stats.size * 0.8, 0, Math.PI * 2); ctx.fill();
                } 
                else {
                    if (currentGraphics && currentGraphics.shadows) {
                        ctx.shadowColor = this.stats.color;
                        ctx.shadowBlur = 15;
                    }
                    ctx.fillStyle = this.stats.color;
                    ctx.beginPath();
                    ctx.arc(orbX, orbY, this.stats.size * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(orbX, orbY - this.stats.size * 0.8);
                    ctx.lineTo(orbX, orbY + this.stats.size * 0.8);
                    ctx.moveTo(orbX - this.stats.size * 0.8, orbY);
                    ctx.lineTo(orbX + this.stats.size * 0.8, orbY);
                    ctx.stroke();
                }
            });
            ctx.restore();
        }
    }
        function createAmbientParticles() {
        if (!currentGraphics) return; 
        const count = currentGraphics.ambientParticles;
        for (let i = 0; i < count; i++) {
            ambientParticles.push(new AmbientParticle());
        }
    }
    const normalizeVector = v => {
        const mag = Math.sqrt(v.x * v.x + v.y * v.y);
        return mag > 0 ? { x: v.x / mag, y: v.y / mag } : { x: 0, y: 0 };
    };
    function createParticleBurst(x, y, count, color, lifespan = 0.5, size = 3, speed = 150) {
        if (!currentGraphics) return; 
        const finalCount = Math.ceil(count * currentGraphics.particleMultiplier);
        for (let i = 0; i < finalCount; i++) {
            particles.push(new Particle(x, y, color, lifespan, Math.random() * size + 1, speed));
        }
    }
    function createParticleLine(startX, startY, endX, endY, color) {
        const dx = endX - startX, dy = endY - startY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const steps = Math.floor(distance / 10);
        const finalSteps = Math.ceil(steps * (currentGraphics ? currentGraphics.particleMultiplier : 1));
        for (let i = 0; i <= finalSteps; i++) {
            const t = i / finalSteps;
            const x = startX + dx * t, y = startY + dy * t;
            particles.push(new Particle(x, y, color, 0.5, Math.random() * 2 + 1, 20));
        }
    }
    function createGridPattern() {
        const gridSize = 100;
        gridCanvas.width = gridSize; gridCanvas.height = gridSize;
        gridCtx.strokeStyle = 'rgba(255,255,255,0.05)'; gridCtx.lineWidth = 2;
        gridCtx.beginPath();
        gridCtx.moveTo(gridSize, 0); gridCtx.lineTo(gridSize, gridSize); gridCtx.lineTo(0, gridSize);
        gridCtx.stroke();
        gridPattern = ctx.createPattern(gridCanvas, 'repeat');
    }
    function giveWaveCompletionBonus() {
        const gemBonus = wave;
        runGems += gemBonus;
        floatingTexts.push(new FloatingText(player.x, player.y - player.size, `ONDA ${wave-1} COMPLETA! +${gemBonus} ‚ô¶`, '#ffd700', 2.5, 18));
        soundManager.play('levelUp');

        if ((wave - 1) % 2 === 0 && wave > 1) {
             powerups.push(new MagnetFragment(CONFIG.MAP_SIZE.width / 2, CONFIG.MAP_SIZE.height / 2));
             floatingTexts.push(new FloatingText(CONFIG.MAP_SIZE.width / 2, CONFIG.MAP_SIZE.height / 2 - 30, `√çM√É APARECEU!`, '#c0c0c0', 3, 18));
        }
    }
    function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        if (canvas.width !== rect.width || canvas.height !== rect.height) {
            canvas.width = rect.width;
            canvas.height = rect.height;
        }
        screenWidth = canvas.width;
        screenHeight = canvas.height;
        isMobile = screenWidth < 768;
        if(camera) camera.updateZoom();
    }
        function init() {
        soundManager = new SoundManager();
        resizeCanvas();
        loadProgress();
        setupEventListeners();
        createGridPattern();
        lastTime = performance.now();
        if (!animationFrameId) gameLoop(lastTime);
    }
    function startGame() {
        DOM.startModal.style.display = 'none'; 
        DOM.hud.style.display = 'block';
        runStats = { enemiesDefeated: 0, damageDealt: 0 };
        player = new Player();
        camera = new Camera(player);
        enemies = []; expOrbs = []; projectiles = []; enemyProjectiles = []; soulGems = []; particles = []; floatingTexts = []; effects = []; powerups = []; shrines = [];
        wave = 1; runGems = 0; gameTime = 0; waveTimer = 30;
        bossWaveActive = false;
        DOM.bossHud.style.display = 'none';
        spawnWave();
        gameState = 'playing';
        history.pushState({ inGame: true }, "");
    }
    function spawnShrine() {
        if (shrines.length > 0) return; 

        const types = ['fury', 'protection', 'wealth'];
        const type = types[Math.floor(Math.random() * types.length)];

        const angle = Math.random() * Math.PI * 2;
        const radius = CONFIG.MAP_SIZE.width * 0.4;
        const x = CONFIG.MAP_SIZE.width / 2 + Math.cos(angle) * radius;
        const y = CONFIG.MAP_SIZE.height / 2 + Math.sin(angle) * radius;

        shrines.push(new Shrine(x, y, type));
    }
    function spawnWave() {
        if(wave > 1 && Math.random() < 0.25) {
            spawnShrine();
        }

        const enemiesToSpawn = 4 + wave * 3;
        let spawnPool;

        // --- Ondas Iniciais ---
        if (wave < 3) {
            // Ondas 1-2: Apenas inimigos b√°sicos para o jogador aprender.
            spawnPool = ['slime', 'bat'];
        } else if (wave < 5) {
            // Ondas 3-4: Introduz o Mago, que ataca √† dist√¢ncia.
            spawnPool = ['slime', 'bat', 'mage'];
        } else if (wave < 10) {
            // Ondas 5-9: Introduz o Bruto, o inimigo mais forte do in√≠cio.
            spawnPool = ['slime', 'bat', 'brute', 'mage'];

        // --- Ondas de Transi√ß√£o (Equil√≠brio P√≥s-Onda 10) ---
        } else if (wave < 14) {
            // Ondas 10-13: Remove os inimigos mais fracos (Slime, Bat).
            // Mant√©m os mais fortes do grupo anterior (Brute, Mage) e introduz dois novos (Wraith, Abyss Worm).
            // Isso cria uma mistura de padr√µes conhecidos com novos desafios.
            spawnPool = ['brute', 'mage', 'wraith', 'abyss_worm'];
        } else {
            // Ondas 14 em diante: O desafio final antes do chefe.
            // Remove os inimigos antigos e introduz os de elite (Crystal Golem, Arcane Sentry).
            // Agora o jogo espera que o jogador domine os novos inimigos.
            spawnPool = ['wraith', 'crystal_golem', 'abyss_worm', 'arcane_sentry'];
        }

        for (let i = 0; i < enemiesToSpawn; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.max(screenWidth, screenHeight) / (camera ? camera.zoom : 1) * 0.8;
            const x = player.x + Math.cos(angle) * radius;
            const y = player.y + Math.sin(angle) * radius;

            let enemyType = spawnPool[Math.floor(Math.random() * spawnPool.length)];
            let newEnemy;
            switch(enemyType) {
                case 'mage': newEnemy = new Mage(x, y); break;
                case 'slime': newEnemy = new Slime(x, y); break;
                case 'bat': newEnemy = new Bat(x, y); break;
                case 'brute': newEnemy = new Brute(x, y); break;
                case 'wraith': newEnemy = new Wraith(x, y); break;
                case 'crystal_golem': newEnemy = new CrystalGolem(x, y); break;
                case 'abyss_worm': newEnemy = new AbyssWorm(x, y); break;
                case 'arcane_sentry': newEnemy = new ArcaneSentry(x, y); break;
                default: newEnemy = new Slime(x,y); break;
            }

            if (wave >= 5 && Math.random() < 0.05 + (wave / 200)) {
                newEnemy.makeChampion();
            }
            enemies.push(newEnemy);
        }
    }
    function startBossWave() {
        bossWaveActive = true;
        enemies.forEach(e => e.takeDamage(9999)); 
        setTimeout(() => {
            const boss = new SpectralElder(player.x, player.y - 600);
            enemies.push(boss);
            DOM.bossName.textContent = CONFIG.ENEMY.spectral_elder.name;
            floatingTexts.push(new FloatingText(player.x, player.y - 100, `CHEFE: ${CONFIG.ENEMY.spectral_elder.name.toUpperCase()}!`, '#ff4d4d', 4, 28));
        }, 5000);
    }
    function startFinalBossWave() {
        bossWaveActive = true;
        enemies.forEach(e => e.takeDamage(9999));
        setTimeout(() => {
            const boss = new MagmaColossus(player.x, player.y - 600);
            enemies.push(boss);
            DOM.bossName.textContent = CONFIG.ENEMY.magma_colossus.name;
            floatingTexts.push(new FloatingText(player.x, player.y - 100, `CHEFE FINAL: ${CONFIG.ENEMY.magma_colossus.name.toUpperCase()}!`, '#ff4500', 5, 32));
        }, 5000);
    }
    function findNearestEnemy(entity, ignoreBoss = false, maxRange = Infinity) {
        let nearest = null;
        let nearestDistSq = maxRange * maxRange;
        for (const enemy of enemies) {
            if (!enemy.isAlive) continue;
            if(ignoreBoss && enemy.isBoss) continue;
            const distSq = (entity.x - enemy.x)**2 + (entity.y - enemy.y)**2;
            if (distSq < nearestDistSq) {
                nearestDistSq = distSq;
                nearest = enemy;
            }
        }
        return nearest;
    }
function handleCollisions() {
        // --- L√ìGICA DE COLIS√ÉO MELEE (CORRIGIDA) ---
        for (const enemy of enemies) {
            if (enemy.damage > 0 && !player.isDashing && (player.x - enemy.x)**2 + (player.y - enemy.y)**2 < (player.size / 2 + enemy.meleeAttackRange)**2) {
                 if (player.isParrying && !player.parriedEnemies.includes(enemy)) {
                    player.parriedEnemies.push(enemy);
                    effects.push(new ParryEffect(player));
                    floatingTexts.push(new FloatingText(enemy.x, enemy.y - enemy.size, 'APARADO!', '#ffff00', 2, 16));
                    createParticleBurst(player.x, player.y, 30, '#ffff00', 0.6, 5, 250);
                    soundManager.play('parry');

                    // APLICA O ATORDOAMENTO E O NOVO EMPURR√ÉO
                    enemy.applyStun(0.5); 
                    if (!enemy.isBoss) {
                        const dx = enemy.x - player.x;
                        const dy = enemy.y - player.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist > 0) {
                            enemy.x += (dx / dist) * CONFIG.PLAYER.parryKnockback;
                            enemy.y += (dy / dist) * CONFIG.PLAYER.parryKnockback;
                        }
                    }

                    if (enemy instanceof Bat && enemy.state === 'dive') {
                        enemy.state = 'recover'; enemy.stateTimer = 1.0;
                    }
                 } else if (!player.isParrying) {
                    player.takeDamage(enemy.damage);
                    if (enemy instanceof Bat && enemy.state === 'dive') {
                        const dx = player.x - enemy.x, dy = player.y - enemy.y, dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist > 0) { player.x += (dx / dist) * 20; player.y += (dy / dist) * 20; }
                        enemy.state = 'recover'; enemy.stateTimer = 1.0;
                    }
                 }
            }
        };

        // --- L√ìGICA DE COLIS√ÉO DE PROJ√âTEIS (INIMIGO -> JOGADOR) ---
        for (let i = projectiles.length - 1; i >= 0; i--) {
            const proj = projectiles[i];
            for (const enemy of enemies) {
                if (proj.hitEnemies.includes(enemy)) continue;
                if ((proj.x - enemy.x)**2 + (proj.y - enemy.y)**2 < (proj.size + enemy.size / 2)**2) {
                    enemy.takeDamage(proj.damage);
                    soundManager.play('hit');
                    proj.hitEnemies.push(enemy);
                    if (proj.hitEnemies.length >= proj.pierce) { 
                        proj.handleExplosion();
                        projectiles.splice(i, 1); 
                        break; 
                    }
                }
            }
        }

        // --- L√ìGICA DE COLIS√ÉO DE PROJ√âTEIS (JOGADOR -> INIMIGO) ---
        for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
            const proj = enemyProjectiles[i];
            const collisionDistSq = (player.size / 2 + proj.size / 2)**2;
            if ((player.x - proj.x)**2 + (player.y - proj.y)**2 < collisionDistSq) {
                if (player.isParrying) {
                    effects.push(new ParryEffect(player));
                    floatingTexts.push(new FloatingText(player.x, player.y - player.size, 'APARADO!', '#ffff00', 2, 16));
                    createParticleBurst(player.x, player.y, 30, '#ffff00', 0.6, 5, 250);
                    soundManager.play('parry');
                    enemyProjectiles.splice(i, 1);
                } else {
                    player.takeDamage(proj.damage);
                    createParticleBurst(proj.x, proj.y, 10, proj.color, 0.4, 3, 100);
                    enemyProjectiles.splice(i, 1);
                }
            } else if (proj instanceof HomingSoul && (player.weapon.id === 'runic_orb' || proj.isPet)) {
                for (const enemy of enemies) {
                    if (proj.hitEnemies?.includes(enemy)) continue;
                    if ((enemy.x - proj.x)**2 + (enemy.y - proj.y)**2 < (enemy.size / 2 + proj.size / 2)**2) {
                        enemy.takeDamage(proj.damage); soundManager.play('hit');
                        if (!proj.hitEnemies) proj.hitEnemies = [];
                        proj.hitEnemies.push(enemy);
                        if (proj.hitEnemies.length >= (proj.pierce || 1)) { enemyProjectiles.splice(i, 1); break; }
                    }
                }
            }
        }

        // --- L√ìGICA DE COLETA DE ITENS ---
        const collectRadiusSq = (player.size + 10)**2;
        for (let i = expOrbs.length - 1; i >= 0; i--) {
            if ((player.x - expOrbs[i].x)**2 + (player.y - expOrbs[i].y)**2 < collectRadiusSq * player.pickupRadiusMultiplier**2) {
                player.addXp(expOrbs[i].value); soundManager.play('collect'); 
                expOrbs.splice(i, 1);
            }
        }
        for (let i = soulGems.length - 1; i >= 0; i--) {
            if ((player.x - soulGems[i].x)**2 + (player.y - soulGems[i].y)**2 < collectRadiusSq * player.pickupRadiusMultiplier**2) {
                runGems++;
                playerData.persistentStats.gemsCollected = (playerData.persistentStats.gemsCollected || 0) + 1;
                soundManager.play('collect');
                soulGems.splice(i, 1);
            }
        }
         for (let i = powerups.length - 1; i >= 0; i--) {
            const powerup = powerups[i];
            const collectionBox = (powerup instanceof HealingOrb) ? collectRadiusSq : (collectRadiusSq * player.pickupRadiusMultiplier**2);
            if ((player.x - powerup.x)**2 + (player.y - powerup.y)**2 < collectionBox) {
                if (powerup instanceof HealingFragment) { player.heal(player.maxHp * powerup.healAmount); } 
                else if (powerup instanceof MagnetFragment) {
                    expOrbs.forEach(orb => { orb.x = player.x; orb.y = player.y; });
                    soulGems.forEach(gem => { gem.x = player.x; gem.y = player.y; });
                }
                else if (powerup instanceof HealingOrb) { player.heal(powerup.value); }
                soundManager.play('levelUp');
                powerups.splice(i, 1);
            }
        }
    }
    function rerollAbilities() {
        if (runGems >= player.rerollCost) {
            runGems -= player.rerollCost;
            player.rerollCost = Math.ceil(player.rerollCost * 1.5);
            if (DOM.abilityModalTitle.textContent.includes("Companheiro")) {
                showPetChoice();
            } else {
                showAbilityChoice();
            }
        }
    }
    function showPetChoice() {
        DOM.abilityModalTitle.textContent = "Escolha um Companheiro!";
        DOM.rerollButton.style.display = 'block';
        DOM.rerollButton.textContent = `Rerrolar (${player.rerollCost} ‚ô¶)`;
        DOM.rerollButton.disabled = runGems < player.rerollCost;

        const petPool = Object.keys(CONFIG.PETS);
        let chosen = [];
        while (chosen.length < 3 && petPool.length > 0) {
            const randomIndex = Math.floor(Math.random() * petPool.length);
            chosen.push(petPool.splice(randomIndex, 1)[0]);
        }

        DOM.abilityOptions.innerHTML = '';
        chosen.forEach(petId => {
            const petInfo = CONFIG.PETS[petId];
            const card = document.createElement('div');
            card.className = 'card p-4 text-center';
            const rarityColor = RARITY_COLORS[4];
            const titleStyle = `color: ${rarityColor}; text-shadow: 0 0 10px ${rarityColor}70;`;
            card.innerHTML = `<h3 class="text-xl mb-2" style="${titleStyle}">${petInfo.name}</h3><p class="text-sm">${petInfo.desc}</p>`;
            card.onclick = () => selectPet(petId);
            DOM.abilityOptions.appendChild(card);
        });
        DOM.abilityModal.style.display = 'flex';
    }
    function selectPet(petId) {
        switch (petId) {
            case 'wisp': player.pet = new WispPet(player); break;
            case 'golem': player.pet = new GolemPet(player); break;
            case 'sprite': player.pet = new SpritePet(player); break;
            case 'sprout': player.pet = new SproutPet(player); break;
            case 'shadow_pup': player.pet = new ShadowPupPet(player); break;
        }
        DOM.abilityModal.style.display = 'none';
        gameState = 'playing';
        lastTime = performance.now();
    }

    // --- Loop Principal e Fun√ß√µes de Desenho ---
    function update(dt) {
        if (gameState !== 'playing') return;
        gameTime += dt;
        if (!bossWaveActive) {
            waveTimer -= dt;
            if (waveTimer <= 0) {
                wave++;
                giveWaveCompletionBonus();
                if (wave === 10) { 
                    startBossWave();
                } else if (wave === 20) {
                    startFinalBossWave();
                } else {
                    waveTimer = 30;
                    spawnWave();
                }
            }
        }
        player.update(dt);
        camera.update();
        for(const e of enemies) e.update(dt);
        for(const p of projectiles) p.update(dt);
        for(const p of enemyProjectiles) p.update(dt);
        for(const o of expOrbs) o.update(dt);
        for(const g of soulGems) g.update(dt);
        for(const p of powerups) p.update(dt);
        for(const p of particles) p.update(dt);
        for(const t of floatingTexts) t.update(dt);
        for(const s of shrines) s.update(dt);
        for(let i = effects.length - 1; i >= 0; i--) {
            effects[i].update(dt);
            if(effects[i].life <= 0) effects.splice(i, 1);
        }
        handleCollisions();
        for (let i = projectiles.length - 1; i >= 0; i--) {
            if (projectiles[i].lifetime <= 0) {
                projectiles[i].handleExplosion();
                projectiles.splice(i, 1);
            }
        }
        for (let i = enemyProjectiles.length - 1; i >= 0; i--) if (enemyProjectiles[i].lifetime <= 0) enemyProjectiles.splice(i, 1);
        for (let i = powerups.length - 1; i >= 0; i--) if (powerups[i].isCollected) powerups.splice(i, 1);
        for (let i = particles.length - 1; i >= 0; i--) if (particles[i].lifespan <= 0) particles.splice(i, 1);
        for (let i = floatingTexts.length - 1; i >= 0; i--) if (floatingTexts[i].lifespan <= 0) floatingTexts.splice(i, 1);
        for (let i = enemies.length - 1; i >= 0; i--) if (!enemies[i].isAlive) enemies.splice(i, 1);
        for (let i = shrines.length - 1; i >= 0; i--) if (shrines[i].isDepleted && shrines[i].activationProgress <=0) shrines.splice(i, 1);
        for(const p of ambientParticles) p.update(dt);
    }
    function draw() {
        ctx.clearRect(0, 0, screenWidth, screenHeight);
        if (!camera) return;
        camera.apply(ctx);
        ctx.fillStyle = gridPattern;
        ctx.fillRect(0, 0, CONFIG.MAP_SIZE.width, CONFIG.MAP_SIZE.height);
        if (currentGraphics && currentGraphics.shadows) {
            ctx.shadowColor = '#ffffff'; ctx.shadowBlur = 5;
        }
        for(const p of ambientParticles) p.draw(ctx);
        if (currentGraphics && currentGraphics.shadows) ctx.shadowBlur = 0;
        for(const o of expOrbs) o.draw(ctx);
        for(const g of soulGems) g.draw(ctx);
        for(const p of powerups) p.draw(ctx);
        for(const s of shrines) s.draw(ctx);
        ctx.save();
        if (currentGraphics && currentGraphics.shadows) ctx.shadowBlur = 0;
        for(const p of particles) p.draw(ctx);
        ctx.restore();
        if(player) player.weapon?.draw(ctx);
        if(player) player.draw(ctx);
        if(player?.pet) player.pet.draw(ctx);
        for(const e of enemies) e.draw(ctx);
        if (playerData.general.showTargetIndicator) drawTargetIndicator();
        for(const p of projectiles) p.draw(ctx);
        for(const p of enemyProjectiles) p.draw(ctx);
        for(const e of effects) e.draw(ctx);
        ctx.save();
        ctx.font = '14px "Press Start 2P"';
        ctx.textAlign = 'center';
        for(const t of floatingTexts) {
            ctx.font = `${t.size || 14}px "Press Start 2P"`;
            t.draw(ctx);
        }
        ctx.restore();
        camera.restore(ctx);
    }
    function drawTargetIndicator() {
        const target = findNearestEnemy(player, false);
        if (!target) return;
        ctx.save();
        const pulse = Math.abs(Math.sin(gameTime * 5));
        ctx.strokeStyle = `rgba(255, 100, 100, ${0.4 + pulse * 0.4})`;
        ctx.lineWidth = 2 + pulse;
        ctx.beginPath();
        ctx.arc(target.x, target.y, target.size, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
    }
function updateUI() {
        if (!player) return;
        DOM.healthBar.style.width = `${(player.hp / player.maxHp) * 100}%`;
        DOM.xpBar.style.width = `${(player.xp / player.xpToNextLevel) * 100}%`;
        DOM.levelText.textContent = `N√≠vel ${player.level}`;
        DOM.runGemsCount.textContent = runGems;
        if (bossWaveActive) {
            DOM.waveTimerText.textContent = `DERROTE O CHEFE!`;
            const boss = enemies.find(e => e.isBoss);
            if (boss) {
                DOM.bossHud.style.display = 'block';
                const bossConfig = CONFIG.ENEMY[boss.type];
                DOM.bossName.textContent = bossConfig.name;
                DOM.bossHealthBar.style.width = `${(boss.hp / boss.maxHp) * 100}%`;
            }
        } else {
             DOM.bossHud.style.display = 'none';
             DOM.waveTimerText.textContent = `Onda ${wave}: ${Math.ceil(waveTimer)}s`;
        }

        // Atualiza√ß√£o dos cooldowns de todas as habilidades
        const dashCooldownProgress = player.dashCooldown > 0 ? player.dashCooldown / CONFIG.PLAYER.dashCooldown : 0;
        DOM.dashCooldownOverlay.style.height = `${dashCooldownProgress * 100}%`;
        DOM.dashButton.style.opacity = dashCooldownProgress > 0 ? '0.7' : '1';

        const parryCooldownProgress = player.parryCooldown > 0 ? player.parryCooldown / CONFIG.PLAYER.parryCooldown : 0;
        DOM.parryCooldownOverlay.style.height = `${parryCooldownProgress * 100}%`;
        DOM.parrySlotCooldownOverlay.style.height = `${parryCooldownProgress * 100}%`;
        DOM.parryButton.style.opacity = parryCooldownProgress > 0 ? '0.7' : '1';

        const pushCooldownProgress = player.pushCooldown > 0 ? player.pushCooldown / CONFIG.PLAYER.pushCooldown : 0;
        DOM.pushCooldownOverlay.style.height = `${pushCooldownProgress * 100}%`;
        DOM.pushSlotCooldownOverlay.style.height = `${pushCooldownProgress * 100}%`;
        DOM.pushButton.style.opacity = pushCooldownProgress > 0 ? '0.7' : '1';
    }
    function gameLoop(timestamp) {
        soundManager.reset();
        const dt = Math.min(0.1, (timestamp - lastTime) / 1000);
        lastTime = timestamp;
        update(dt);
        draw();
        if (gameState === 'playing') updateUI();
        animationFrameId = requestAnimationFrame(gameLoop);
    }
    // --- Metaprogresso e UI do Menu ---
    function renderQuestsModal() {
        const templateNode = document.getElementById('quest-card-template');

        function renderCategory(category, container) {
            container.innerHTML = '';
            const quests = CONFIG.QUESTS[category];
            quests.forEach(quest => {
                const template = templateNode.content.cloneNode(true);
                const progress = playerData.persistentStats[quest.stat] || 0;
                const target = quest.target;
                const isComplete = progress >= target;
                const isClaimed = playerData.questProgress[quest.id]?.claimed || false;

                template.querySelector('.quest-title').textContent = quest.desc;
                template.querySelector('.quest-progress-text').textContent = `${Math.min(progress, target)} / ${target}`;
                template.querySelector('.quest-progress-bar').style.width = `${Math.min(progress / target, 1) * 100}%`;
                template.querySelector('.quest-reward').innerHTML = `${quest.reward} <span class="text-yellow-400">‚ô¶</span>`;

                const button = template.querySelector('.quest-claim-button');
                if (isClaimed) {
                    button.textContent = 'Coletado';
                    button.disabled = true;
                } else if (isComplete) {
                    button.textContent = 'Coletar';
                    button.disabled = false;
                    button.onclick = () => claimQuestReward(quest.id);
                } else {
                    button.textContent = 'Em Progresso';
                    button.disabled = true;
                }
                container.appendChild(template);
            });
        }

        renderCategory('easy', DOM.easyQuestsContainer);
        renderCategory('medium', DOM.mediumQuestsContainer);
        renderCategory('hard', DOM.hardQuestsContainer);
    }
    function claimQuestReward(questId) {
        let quest;
        for (const category in CONFIG.QUESTS) {
            const found = CONFIG.QUESTS[category].find(q => q.id === questId);
            if (found) {
                quest = found;
                break;
            }
        }
        if (quest && !playerData.questProgress[quest.id]?.claimed) {
            playerData.totalSoulGems += quest.reward;
            if (!playerData.questProgress[quest.id]) {
                playerData.questProgress[quest.id] = {};
            }
            playerData.questProgress[quest.id].claimed = true;
            soundManager.play('buy');
            saveProgress();
            updateGemDisplays();
            renderQuestsModal();
        }
    }
    function renderUpgradesModal() {
        DOM.upgradesGems.textContent = playerData.totalSoulGems;
        DOM.upgradesContainer.innerHTML = '';
        const templateNode = document.getElementById('upgrade-card-template');
        for (const id in CONFIG.PERMANENT_UPGRADES) {
            const template = templateNode.content.cloneNode(true);
            const upgrade = CONFIG.PERMANENT_UPGRADES[id];
            const level = playerData.purchasedUpgrades[id] || 0, cost = upgrade.cost(level), isMax = level >= upgrade.maxLevel;
            template.querySelector('.card-title').textContent = upgrade.name;
            template.querySelector('.card-description').textContent = upgrade.desc;
            template.querySelector('.card-level').textContent = `${level} / ${upgrade.maxLevel}`;
            template.querySelector('.card-bonus').textContent = upgrade.format(level);
            const button = template.querySelector('.card-button');
            button.textContent = isMax ? 'MAX' : `Comprar (${cost} ‚ô¶)`;
            button.disabled = isMax || playerData.totalSoulGems < cost;
            button.onclick = () => buyUpgrade(id);
            DOM.upgradesContainer.appendChild(template);
        }
    }
    function renderWeaponShop() {
        DOM.weaponShopContainer.innerHTML = '';
        const templateNode = document.getElementById('upgrade-card-template');
        for (const id in CONFIG.WEAPONS) {
            const weapon = CONFIG.WEAPONS[id];

            const isUnlockable = id === 'spectral_blades' || id === 'singularity_cannon' || id === 'runic_orb';
            if (isUnlockable && !playerData.spectralElderDefeated) {
                continue;
            }

            const template = templateNode.content.cloneNode(true);
            const isUnlocked = playerData.unlockedWeapons.includes(id);
            const isEquipped = playerData.equippedWeapon === id;
            template.querySelector('.card-title').textContent = weapon.name;
            template.querySelector('.card-description').textContent = weapon.desc;
            template.querySelector('.card-level-text').style.display = 'none';
            template.querySelector('.card-bonus-text').textContent = `Dano: ${weapon.damage}, Recarga: ${weapon.cooldown}s`;
            const card = template.querySelector('.card');
            const button = template.querySelector('.card-button');

            if (isEquipped) {
                button.textContent = 'Equipado';
                button.disabled = true;
                card.classList.add('locked');
            } else if (isUnlocked) {
                button.textContent = 'Equipar';
                button.onclick = () => equipWeapon(id);
            } else {
                button.textContent = `Comprar (${weapon.cost} ‚ô¶)`;
                button.disabled = playerData.totalSoulGems < weapon.cost;
                button.onclick = () => buyWeapon(id);
            }
            DOM.weaponShopContainer.appendChild(template);
        }
    }
    function buyUpgrade(id) {
        const upgrade = CONFIG.PERMANENT_UPGRADES[id];
        const level = playerData.purchasedUpgrades[id] || 0, cost = upgrade.cost(level);
        if (playerData.totalSoulGems >= cost && level < upgrade.maxLevel) {
            playerData.totalSoulGems -= cost; playerData.purchasedUpgrades[id] = level + 1;
            playerData.persistentStats.upgradesPurchased = (playerData.persistentStats.upgradesPurchased || 0) + 1;
            soundManager.play('buy'); saveProgress(); updateGemDisplays(); renderUpgradesModal();
        }
    }
     function buyWeapon(id) {
        const weapon = CONFIG.WEAPONS[id];
        if (playerData.totalSoulGems >= weapon.cost && !playerData.unlockedWeapons.includes(id)) {
            playerData.totalSoulGems -= weapon.cost; playerData.unlockedWeapons.push(id);
            soundManager.play('buy'); saveProgress(); updateGemDisplays(); renderWeaponShop();
        }
    }
    function equipWeapon(id) {
        if (playerData.unlockedWeapons.includes(id)) {
            playerData.equippedWeapon = id;
            soundManager.play('uiClick'); saveProgress(); renderWeaponShop();
        }
    }
    function updateGemDisplays() {
        DOM.totalGems.textContent = playerData.totalSoulGems;
        DOM.upgradesGems.textContent = playerData.totalSoulGems;
        DOM.questsGemsCount.textContent = playerData.totalSoulGems;
    }
    function saveProgress() { localStorage.setItem('finalVertexSave', JSON.stringify(playerData)); }
    function loadProgress() {
        const saved = localStorage.getItem('finalVertexSave');
        if (saved) {
            const loadedData = JSON.parse(saved);
            Object.keys(playerData).forEach(key => {
                if (loadedData[key] !== undefined) {
                    if (typeof playerData[key] === 'object' && playerData[key] !== null && !Array.isArray(playerData[key])) {
                        Object.assign(playerData[key], loadedData[key]);
                    } else {
                        playerData[key] = loadedData[key];
                    }
                }
            });
             if (!playerData.persistentStats) playerData.persistentStats = {};
             if (!playerData.questProgress) playerData.questProgress = {};
             if (playerData.spectralElderDefeated === undefined) playerData.spectralElderDefeated = false;
        }
        updateGemDisplays();
        applyAllSettings();
        const lastSeenVersion = localStorage.getItem('lastSeenVersion');
        if (lastSeenVersion !== GAME_VERSION) {
            DOM.changelogModal.style.display = 'flex';
            localStorage.setItem('lastSeenVersion', GAME_VERSION);
        }
    }
    function applyAllSettings() {
        applyAudioSettings();
        applyGraphicsSettings();
        applyControlsLayout();
        applyGeneralSettings();
    }
    function applyAudioSettings() {
        DOM.masterVolumeSlider.value = playerData.audio.masterVolume;
        DOM.sfxVolumeSlider.value = playerData.audio.sfxVolume;
        if (soundManager) soundManager.setMasterVolume(playerData.audio.masterVolume);
    }
    function applyGraphicsSettings() {
        const quality = playerData.graphics.quality || 'medium';
        currentGraphics = CONFIG.GRAPHICS[quality];
        [DOM.qualityLowBtn, DOM.qualityMediumBtn, DOM.qualityHighBtn].forEach(btn => btn.classList.remove('active'));
        if (quality === 'low') DOM.qualityLowBtn.classList.add('active');
        else if (quality === 'medium') DOM.qualityMediumBtn.classList.add('active');
        else if (quality === 'high') DOM.qualityHighBtn.classList.add('active');
        DOM.screenShakeBtn.textContent = playerData.graphics.screenShake ? 'Ligado' : 'Desligado';
        DOM.screenShakeBtn.classList.toggle('active', playerData.graphics.screenShake);
        DOM.effectsOpacitySlider.value = playerData.graphics.effectsOpacity;
        ambientParticles = [];
        createAmbientParticles();
    }
    function applyControlsLayout() {
        const gameContainer = document.getElementById('game-container');
        if (playerData.controls.inverted) {
            gameContainer.classList.add('controls-inverted');
            DOM.invertControlsBtn.textContent = 'Invertido';
            DOM.invertControlsBtn.classList.add('active');
        } else {
            gameContainer.classList.remove('controls-inverted');
            DOM.invertControlsBtn.textContent = 'Padr√£o';
            DOM.invertControlsBtn.classList.remove('active');
        }
    }
    function applyGeneralSettings() {
        DOM.targetIndicatorBtn.textContent = playerData.general.showTargetIndicator ? 'Ligado' : 'Desligado';
        DOM.targetIndicatorBtn.classList.toggle('active', playerData.general.showTargetIndicator);
    }
    function setGraphicsQuality(quality) {
        playerData.graphics.quality = quality;
        applyGraphicsSettings();
        saveProgress();
    }
    function updatePauseSummary() {
        if (!player) return;
        DOM.pauseSummary.innerHTML = ''; 
        let weaponHtml = '<h3>Arma</h3><ul>';
        const weaponName = player.weapon.isEvolved ? `${player.weapon.stats.name} (EVO)` : player.weapon.stats.name;
        weaponHtml += `<li>${weaponName}</li>`;
        weaponHtml += '</ul>';
        DOM.pauseSummary.innerHTML += weaponHtml;

        if (player.pet) {
            let petHtml = '<h3 class="mt-4">Companheiro</h3><ul>';
            petHtml += `<li>${CONFIG.PETS[player.pet.id].name}</li>`;
            petHtml += '</ul>';
            DOM.pauseSummary.innerHTML += petHtml;
        }

        let abilitiesHtml = '<h3 class="mt-4">Melhorias</h3><ul>';
        const abilityNames = { ...CONFIG.GENERAL_ABILITIES.reduce((obj, item) => ({...obj, [item.id]: item.name }), {}),
            ...Object.values(CONFIG.WEAPON_UPGRADES).flat().reduce((obj, item) => ({...obj, [item.id]: item.name }), {}),
            ...CONFIG.PET_UPGRADES.reduce((obj, item) => ({...obj, [item.id]: item.name }), {})
        };
        const sortedAbilities = Object.keys(player.abilityLevels).sort();
        if (sortedAbilities.length > 0) {
            sortedAbilities.forEach(id => {
                 const name = abilityNames[id] || id;
                 const level = player.abilityLevels[id];
                 abilitiesHtml += `<li>${name} - N√≠vel ${level}</li>`;
            });
        } else {
            abilitiesHtml += '<li>Nenhuma melhoria adquirida.</li>';
        }
        abilitiesHtml += '</ul>';
        DOM.pauseSummary.innerHTML += abilitiesHtml;
    }
    function togglePause(isManual = true) {
        if (gameState === 'gameOver' || gameState === 'victory' || (gameState === 'paused_ability' && isManual)) return;
        const shouldPause = gameState === 'playing';
        if (shouldPause) {
            gameState = 'paused';
            updatePauseSummary();
            DOM.pauseModal.style.display = 'flex';
        } else if (gameState === 'paused') {
            gameState = 'playing';
            DOM.pauseModal.style.display = 'none';
            lastTime = performance.now(); 
        }
    }
    function showAbilityChoice() {
        if (gameState === 'gameOver' || gameState === 'paused' || gameState === 'victory') return;
        gameState = 'paused_ability';

        DOM.abilityModalTitle.textContent = "Escolha uma Melhoria!";
        DOM.rerollButton.style.display = 'block';
        DOM.rerollButton.textContent = `Rerrolar (${player.rerollCost} ‚ô¶)`;
        DOM.rerollButton.disabled = runGems < player.rerollCost;

        const weaponId = player.weapon.id;

        const evolution = CONFIG.WEAPON_EVOLUTIONS[weaponId];
        let evolutionAvailable = null;
        if (evolution && !player.weapon.isEvolved) {
            const allReqsMet = evolution.requires.every(reqId => {
                const reqUpgrade = CONFIG.WEAPON_UPGRADES[weaponId].find(u => u.id === reqId);
                return (player.abilityLevels[reqId] || 0) >= (reqUpgrade.max || 1);
            });
            if (allReqsMet) {
                evolutionAvailable = evolution;
            }
        }

        let possibleAbilities = [];
        possibleAbilities.push(...CONFIG.GENERAL_ABILITIES.filter(a => (player.abilityLevels[a.id] || 0) < (a.max || 99)));
        possibleAbilities.push(...(CONFIG.WEAPON_UPGRADES[weaponId] || []).filter(a => (player.abilityLevels[a.id] || 0) < (a.max || 99)));

        if (!player.pet && Math.random() < 0.25) { 
            possibleAbilities.push({
                id: 'summon_pet',
                name: 'Invocar Companheiro',
                desc: 'Escolha um aliado fiel para te ajudar na batalha.',
                max: 1,
                isPetSummon: true,
                apply: () => { showPetChoice(); }
            });
        }

        if (player.pet) {
            const petUpgrades = CONFIG.PET_UPGRADES.filter(up =>
                up.for.includes(player.pet.id) && (player.abilityLevels[up.id] || 0) < up.max
            );
            possibleAbilities.push(...petUpgrades);
        }

        let chosen = [];
        if (evolutionAvailable) {
            chosen.push(evolutionAvailable);
        }

        while (chosen.length < 3 && possibleAbilities.length > 0) {
            const randomIndex = Math.floor(Math.random() * possibleAbilities.length);
            chosen.push(possibleAbilities.splice(randomIndex, 1)[0]);
        }

        if (chosen.length < 3) {
            const fallbacks = [
                { id: 'gem_cache', name: 'Tesouro', desc: 'Ganhe 25 gemas.', max: 99, apply: () => { runGems += 25; } },
                { id: 'health_potion', name: 'Po√ß√£o', desc: 'Recupere 30% da vida m√°xima.', max: 99, apply: () => { player.heal(player.maxHp * 0.3); } }
            ];
            while(chosen.length < 3 && fallbacks.length > 0) {
                 chosen.push(fallbacks.shift());
            }
        }

        DOM.abilityOptions.innerHTML = '';
        chosen.forEach(ability => {
            const card = document.createElement('div');
            card.className = 'card p-4 text-center';
            const currentLevel = player.abilityLevels[ability.id] || 0;

            let rarity = 1;
            if (ability.id.startsWith('evolve') || ability.isPetSummon) {
                rarity = 5;
            } else if (ability.id.startsWith('pet_')) {
                rarity = 4;
            } else if (ability.max) {
                 rarity = currentLevel + 1;
                 if (ability.max === 3) {
                    rarity = THREE_LEVEL_RARITY[rarity] || 1;
                 }
            }
            const rarityColor = RARITY_COLORS[rarity] || '#ffffff';

            const titleStyle = `color: ${rarityColor}; text-shadow: 0 0 10px ${rarityColor}70;`;

            let displayName = ability.name;
            if (ability.max && !ability.id.startsWith('evolve') && !ability.isPetSummon) {
                displayName += ` <span class="text-sm opacity-75">(N√≠vel ${currentLevel + 1}/${ability.max})</span>`;
            }

            let displayDesc = Array.isArray(ability.desc) ? ability.desc[currentLevel] : ability.desc;

            if (ability.id.startsWith('evolve')) card.classList.add('evolution-card');

            card.innerHTML = `
                <div class="absolute top-0 left-0 w-full h-2" style="background-color: ${rarityColor};"></div>
                <h3 class="text-xl mb-2 mt-2" style="${titleStyle}">${displayName}</h3>
                <p class="text-sm">${displayDesc || ''}</p>
            `;
            card.onclick = () => selectAbility(ability);
            DOM.abilityOptions.appendChild(card);
        });

        DOM.abilityModal.style.display = 'flex';
    }

    function selectAbility(ability) {
        if (ability.isPetSummon) {
            ability.apply();
            return;
        }
        const weaponId = player.weapon.id;
        const isWeaponUpgrade = (CONFIG.WEAPON_UPGRADES[weaponId] || []).some(w => w.id === ability.id);
        if (isWeaponUpgrade || ability.id.startsWith('evolve')) {
            player.weaponUpgradeLuck = 0;
        } else {
            player.weaponUpgradeLuck++;
        }
        if (!ability.id.startsWith('evolve')) {
            player.abilityLevels[ability.id] = (player.abilityLevels[ability.id] || 0) + 1;
        }
        ability.apply(player);
        DOM.abilityModal.style.display = 'none';
        gameState = 'playing';
        lastTime = performance.now();
    }

    function gameOver(isVictory = false) {
        if (gameState === 'gameOver' || gameState === 'victory') return;

        if (isVictory) {
            gameState = 'victory';
            DOM.endScreenTitle.textContent = 'Vit√≥ria!';
            DOM.endScreenTitle.className = 'text-3xl sm:text-4xl mb-2 text-yellow-400';
            DOM.finalGemsContainer.style.display = 'none';
        } else {
            gameState = 'gameOver';
            soundManager.play('gameOver');
            DOM.endScreenTitle.textContent = 'Fim de Jogo';
            DOM.endScreenTitle.className = 'text-3xl sm:text-4xl mb-2 text-red-500';
            DOM.finalGemsContainer.style.display = 'block';
            DOM.finalGems.textContent = runGems;
        }

        playerData.totalSoulGems += runGems;

        playerData.persistentStats.gamesPlayed = (playerData.persistentStats.gamesPlayed || 0) + 1;
        playerData.persistentStats.totalDamageDealt = (playerData.persistentStats.totalDamageDealt || 0) + runStats.damageDealt;
        playerData.persistentStats.maxLevelReached = Math.max(playerData.persistentStats.maxLevelReached || 0, player.level);
        playerData.persistentStats.maxTimeSurvived = Math.max(playerData.persistentStats.maxTimeSurvived || 0, gameTime);
        playerData.persistentStats.maxWaveReached = Math.max(playerData.persistentStats.maxWaveReached || 0, wave);

        saveProgress();
        const minutes = Math.floor(gameTime / 60), seconds = Math.floor(gameTime % 60).toString().padStart(2, '0');
        DOM.timeSurvived.textContent = `${minutes}:${seconds}`;
        DOM.enemiesDefeatedStat.textContent = runStats.enemiesDefeated;
        DOM.damageDealtStat.textContent = Math.round(runStats.damageDealt);
        DOM.levelReachedStat.textContent = player.level;
        DOM.gameOverModal.style.display = 'flex';
    }
    // --- Event Listeners ---
 function setupEventListeners() {
        document.body.addEventListener('click', () => soundManager.init(), { once: true });
        document.body.addEventListener('click', (e) => {
            if (e.target.closest('button, .card:not(.locked)')) soundManager.play('uiClick');
        });
        DOM.startButton.addEventListener('click', startGame);
        DOM.rerollButton.addEventListener('click', rerollAbilities);
        DOM.upgradesButton.addEventListener('click', () => {
            renderUpgradesModal(); renderWeaponShop();
            DOM.startModal.style.display = 'none'; DOM.upgradesModal.style.display = 'flex';
        });
        DOM.upgradesBackButton.addEventListener('click', () => {
            DOM.upgradesModal.style.display = 'none'; DOM.startModal.style.display = 'flex';
        });
        DOM.questsButton.addEventListener('click', () => {
            renderQuestsModal();
            DOM.startModal.style.display = 'none'; DOM.questsModal.style.display = 'flex';
        });
        DOM.questsBackButton.addEventListener('click', () => {
            DOM.questsModal.style.display = 'none'; DOM.startModal.style.display = 'flex';
        });
        DOM.optionsButton.addEventListener('click', () => {
            DOM.startModal.style.display = 'none';
            DOM.optionsModal.style.display = 'flex';
        });
        DOM.optionsBackButton.addEventListener('click', () => {
            DOM.optionsModal.style.display = 'none';
            DOM.startModal.style.display = 'flex';
        });
        DOM.restartButton.addEventListener('click', () => {
            DOM.gameOverModal.style.display = 'none'; 
            DOM.hud.style.display = 'none';
            DOM.startModal.style.display = 'flex';
            updateGemDisplays(); 
            gameState = 'start';
        });
        DOM.closeChangelogButton.addEventListener('click', () => {
            DOM.changelogModal.style.display = 'none';
        });
        DOM.showUpgradesTab.addEventListener('click', () => {
            DOM.upgradesContainer.style.display = 'grid'; DOM.weaponShopContainer.style.display = 'none';
            DOM.showUpgradesTab.classList.add('active-tab'); DOM.showWeaponsTab.classList.remove('active-tab');
        });
        DOM.showWeaponsTab.addEventListener('click', () => {
            DOM.upgradesContainer.style.display = 'none'; DOM.weaponShopContainer.style.display = 'grid';
            DOM.showUpgradesTab.classList.remove('active-tab'); DOM.showWeaponsTab.classList.add('active-tab');
        });
        const questTabs = [
            { btn: DOM.showEasyQuestsTab, content: DOM.easyQuestsContainer },
            { btn: DOM.showMediumQuestsTab, content: DOM.mediumQuestsContainer },
            { btn: DOM.showHardQuestsTab, content: DOM.hardQuestsContainer }
        ];
        questTabs.forEach(tab => {
            tab.btn.addEventListener('click', () => {
                questTabs.forEach(t => {
                    t.btn.classList.remove('active-tab');
                    t.content.style.display = 'none';
                });
                tab.btn.classList.add('active-tab');
                tab.content.style.display = 'grid';
            });
        });
        const optionsTabs = [
            { btn: DOM.showGeneralTab, content: DOM.generalSettingsTab },
            { btn: DOM.showGraphicsTab, content: DOM.graphicsSettingsTab },
            { btn: DOM.showAudioTab, content: DOM.audioSettingsTab }
        ];
        optionsTabs.forEach(tab => {
            tab.btn.addEventListener('click', () => {
                optionsTabs.forEach(t => {
                    t.btn.classList.remove('active-tab');
                    t.content.style.display = 'none';
                });
                tab.btn.classList.add('active-tab');
                tab.content.style.display = 'block';
            });
        });
        DOM.masterVolumeSlider.addEventListener('input', () => {
            playerData.audio.masterVolume = parseFloat(DOM.masterVolumeSlider.value);
            applyAudioSettings(); saveProgress();
        });
        DOM.sfxVolumeSlider.addEventListener('input', () => {
            playerData.audio.sfxVolume = parseFloat(DOM.sfxVolumeSlider.value);
            applyAudioSettings(); saveProgress();
        });
        DOM.qualityLowBtn.addEventListener('click', () => setGraphicsQuality('low'));
        DOM.qualityMediumBtn.addEventListener('click', () => setGraphicsQuality('medium'));
        DOM.qualityHighBtn.addEventListener('click', () => setGraphicsQuality('high'));
        DOM.invertControlsBtn.addEventListener('click', () => {
            playerData.controls.inverted = !playerData.controls.inverted;
            applyControlsLayout(); saveProgress();
        });
        DOM.targetIndicatorBtn.addEventListener('click', () => {
            playerData.general.showTargetIndicator = !playerData.general.showTargetIndicator;
            applyGeneralSettings(); saveProgress();
        });
        DOM.screenShakeBtn.addEventListener('click', () => {
            playerData.graphics.screenShake = !playerData.graphics.screenShake;
            applyGraphicsSettings(); saveProgress();
        });
        DOM.effectsOpacitySlider.addEventListener('input', () => {
            playerData.graphics.effectsOpacity = parseFloat(DOM.effectsOpacitySlider.value);
            applyGraphicsSettings(); saveProgress();
        });
        DOM.resumeButton.addEventListener('click', () => togglePause(true));
        DOM.quitButton.addEventListener('click', () => {
            gameState = 'start';
            DOM.pauseModal.style.display = 'none';
            DOM.hud.style.display = 'none';
            DOM.startModal.style.display = 'flex';
            updateGemDisplays();
        });
        window.addEventListener('keydown', e => {
            const key = e.key.toLowerCase();
            keys[key] = true;
            if (key === ' ' || key === 'shift') { e.preventDefault(); player?.dash(); }
            if (key === 'q') { e.preventDefault(); player?.activateParry(); }
            if (key === 'e') { e.preventDefault(); player?.activatePush(); }
            if (key === 'escape') { 
                e.preventDefault(); 
                if (gameState === 'playing' || gameState === 'paused') {
                    togglePause(true);
                }
            }
        });
        window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });
        window.addEventListener('popstate', (event) => {
            if (gameState === 'playing') {
                togglePause(true);
                history.pushState({ inGame: true }, "");
            }
        });
        window.addEventListener('resize', resizeCanvas);
        let joystickID = null;
        let joystickCenter = { x: 0, y: 0 };
        const joystickMaxDist = 50;
        window.addEventListener('touchstart', e => {
            if (joystickID !== null || gameState !== 'playing') return;
            const touch = e.changedTouches[0];

            const isButtonTouch = e.target.closest('.ability-btn');
            if(isButtonTouch) return;

            const joystickSideCondition = playerData.controls.inverted ?
                (touch.clientX > window.innerWidth / 2) :
                (touch.clientX < window.innerWidth / 2);
            if (joystickSideCondition) {
                e.preventDefault();
                joystickID = touch.identifier;
                joystickCenter.x = touch.clientX; joystickCenter.y = touch.clientY;
                DOM.joystickContainer.style.left = `${joystickCenter.x}px`;
                DOM.joystickContainer.style.top = `${joystickCenter.y}px`;
                DOM.joystickContainer.style.opacity = '1';
            }
        }, { passive: false });
        window.addEventListener('touchmove', e => {
            if (joystickID === null) return;
            e.preventDefault(); 
            for(let touch of e.changedTouches){
                if(touch.identifier === joystickID){
                    let dx = touch.clientX - joystickCenter.x, dy = touch.clientY - joystickCenter.y;
                    const mag = Math.sqrt(dx*dx + dy*dy);
                    if (mag > joystickMaxDist) {
                        dx = (dx / mag) * joystickMaxDist; dy = (dy / mag) * joystickMaxDist;
                    }
                    DOM.joystickThumb.style.transform = `translate(${dx}px, ${dy}px)`;
                    joystickVector.x = dx / joystickMaxDist;
                    joystickVector.y = dy / joystickMaxDist;
                    break;
                }
            }
        }, { passive: false });
        window.addEventListener('touchend', e => {
            if (joystickID === null) return;
            for(let touch of e.changedTouches){
                if(touch.identifier === joystickID){
                    joystickID = null;
                    DOM.joystickContainer.style.opacity = '0';
                    DOM.joystickThumb.style.transform = `translate(0px, 0px)`;
                    joystickVector = { x: 0, y: 0 };
                    break;
                }
            }
        });
        // Eventos para todos os bot√µes de habilidade
        DOM.dashButton.addEventListener('touchstart', (e) => { e.preventDefault(); player?.dash(); }, { passive: false });
        DOM.parryButton.addEventListener('touchstart', (e) => { e.preventDefault(); player?.activateParry(); }, { passive: false });
        DOM.pushButton.addEventListener('touchstart', (e) => { e.preventDefault(); player?.activatePush(); }, { passive: false });
    }
    // --- Iniciar o Jogo ---
    init();
        </script>
    <script>
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('./sw.js')
            .then(registration => {
              console.log('Service Worker registrado com sucesso:', registration);
            })
            .catch(error => {
              console.log('Falha ao registrar o Service Worker:', error);
            });
        });
      }
    </script>
</body>
</html>